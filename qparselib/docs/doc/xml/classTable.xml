<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="classTable" kind="class" language="C++" prot="public">
    <compoundname>Table</compoundname>
    <basecompoundref refid="classAtable" prot="public" virt="non-virtual">Atable&lt; P &gt;</basecompoundref>
    <includes local="no">Table.hpp</includes>
    <templateparamlist>
      <param>
        <type>class</type>
        <declname>P</declname>
        <defname>P</defname>
      </param>
      <param>
        <type>class</type>
        <declname>R</declname>
        <defname>R</defname>
      </param>
      <param>
        <type>class</type>
        <declname>H</declname>
        <defname>H</defname>
      </param>
    </templateparamlist>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classTable_1a5a8b25168c3af6596d29ac4dbbaa0650" prot="private" static="no" mutable="no">
        <type>MapRecord&lt; P, R, H &gt;</type>
        <definition>MapRecord&lt;P,R,H&gt; Table&lt; P, R, H &gt;::_table</definition>
        <argsstring></argsstring>
        <name>_table</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="137" column="1" bodyfile="src/table/Table.hpp" bodystart="137" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classTable_1a0b1dce071cf54f33fde24854ef373c06" prot="private" static="no" mutable="no">
        <type>MapInstances&lt; P, H &gt;</type>
        <definition>MapInstances&lt;P,H&gt; Table&lt; P, R, H &gt;::_instances</definition>
        <argsstring></argsstring>
        <name>_instances</name>
        <briefdescription>
<para>associate to every registered partial ptr p an iterator to pairs (p&apos;, r) where p&apos; is a complete instance of p assciated to r in _table </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="142" column="1" bodyfile="src/table/Table.hpp" bodystart="142" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classTable_1a7298de4734f3bc98c30407a08fe5671b" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t Table&lt; P, R, H &gt;::_nb_rows</definition>
        <argsstring></argsstring>
        <name>_nb_rows</name>
        <briefdescription>
<para>stats. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="147" column="1" bodyfile="src/table/Table.hpp" bodystart="147" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classTable_1a298e3a396f9cc2decc08b0f9801c1bc2" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t Table&lt; P, R, H &gt;::_nb_runs</definition>
        <argsstring></argsstring>
        <name>_nb_runs</name>
        <briefdescription>
<para>stats. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="149" column="1" bodyfile="src/table/Table.hpp" bodystart="149" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classTable_1a75c05943dcc9afb9ee0af010143a692e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Table&lt; P, R, H &gt;::Table</definition>
        <argsstring>(Parser&lt; P &gt; *env, RunCompare&lt; P &gt; comp)</argsstring>
        <name>Table</name>
        <param>
          <type><ref refid="classParser" kindref="compound">Parser</ref>&lt; P &gt; *</type>
          <declname>env</declname>
        </param>
        <param>
          <type>RunCompare&lt; P &gt;</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>concrete table. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="see"><para><ref refid="classAtable" kindref="compound">Atable</ref> for arguments </para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>env</parametername>
</parameternamelist>
<parameterdescription>
<para>the parsing environment must not be NULL </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="72" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1a589746398a8320b124a5b19f37b9851f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Table&lt; P, R, H &gt;::~Table</definition>
        <argsstring>()</argsstring>
        <name>~Table</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="74" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1a2e8c9b5856741684b1ec7d8fc640cc81" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classRun" kindref="compound">Run</ref>&lt; P &gt; *</type>
        <definition>virtual Run&lt;P&gt;* Table&lt; P, R, H &gt;::best</definition>
        <argsstring>(const P &amp;p)</argsstring>
        <name>best</name>
        <reimplements refid="classAtable_1a60515b93afede66f01a0e89edb563800">best</reimplements>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>return k-best run pointed by p or NULL if there is none. k is either included in p or the default value 1. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>must be complete. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="81" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1ace006d9777eee7bb4835f821bc5c9467" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classRhythmTree" kindref="compound">RhythmTree</ref> *</type>
        <definition>virtual RhythmTree* Table&lt; P, R, H &gt;::bestTree</definition>
        <argsstring>(const P &amp;p)</argsstring>
        <name>bestTree</name>
        <reimplements refid="classAtable_1af3a86206727f9d28cd3e962f709b9bc2">bestTree</reimplements>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>tree corresponding to the k-best run in p. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="84" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1a53788fcf01e286097b3c0d7c7573d61f" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classRhythmTree" kindref="compound">RhythmTree</ref> *</type>
        <definition>virtual RhythmTree* Table&lt; P, R, H &gt;::bestTree</definition>
        <argsstring>(Run&lt; P &gt; *r)</argsstring>
        <name>bestTree</name>
        <reimplements refid="classAtable_1a48dfc1adb76a6d50824f28df2f8cd692">bestTree</reimplements>
        <param>
          <type><ref refid="classRun" kindref="compound">Run</ref>&lt; P &gt; *</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>when the k-best run in p is already computed. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="87" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1a69ccf554edee39f61692c26a3b4667e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classRecord" kindref="compound">Record</ref>&lt; P &gt; *</type>
        <definition>Record&lt;P&gt;* Table&lt; P, R, H &gt;::add</definition>
        <argsstring>(const P &amp;p)</argsstring>
        <name>add</name>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>if p complete, create a new record in table for it and process it (add runs), if p partial, process it (register instances to table) with addPartial. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>can be partial or complete. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="warning"><para>p must have yet no associated record in table when complete. </para>
</simplesect>
<simplesect kind="warning"><para>p must not have been added before if partial (no registered instances). </para>
</simplesect>
<simplesect kind="return"><para>a pointer to the newly created record if p complete. </para>
</simplesect>
<simplesect kind="return"><para>a NULL pointer in this case if p partial. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="109" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1a9231e3b8782acfabbafe1f1dcb85a3bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type>size_t</type>
        <definition>virtual size_t Table&lt; P, R, H &gt;::add</definition>
        <argsstring>(const P &amp;p, Run&lt; P &gt; *r, Record&lt; P &gt; *i)</argsstring>
        <name>add</name>
        <reimplements refid="classAtable_1ab644eecedb520d67da426f9170a6213b">add</reimplements>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classRun" kindref="compound">Run</ref>&lt; P &gt; *</type>
          <declname>r</declname>
        </param>
        <param>
          <type><ref refid="classRecord" kindref="compound">Record</ref>&lt; P &gt; *</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>can be complete or partial. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>can be complete or partial. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>if p is complete, then i must be an pointer to the entry for p in table, otherwise (p partial), i is NULL.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
add possible instances of run r to the entries in table for corresp. to possible instances for p. dispatch to the four functions below according to p and r. <simplesect kind="return"><para>0 if the run or one instance of the run (at least) was added to the table. </para>
</simplesect>
<simplesect kind="return"><para>&gt; 0 otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="124" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1aea047b02e7a9f2d714248903f52f5722" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>size_t</type>
        <definition>virtual size_t Table&lt; P, R, H &gt;::nb_entries</definition>
        <argsstring>()</argsstring>
        <name>nb_entries</name>
        <reimplements refid="classAtable_1a90e01b017faeec6869df32bd50ce5b35">nb_entries</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="128" column="1" bodyfile="src/table/Table.hpp" bodystart="128" bodyend="128"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1a8e4b509c921bf151b3601fca7704aaee" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type>size_t</type>
        <definition>virtual size_t Table&lt; P, R, H &gt;::nb_runs</definition>
        <argsstring>()</argsstring>
        <name>nb_runs</name>
        <reimplements refid="classAtable_1a66029b49ab5cece68c4a0635a821b877">nb_runs</reimplements>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="129" column="1" bodyfile="src/table/Table.hpp" bodystart="129" bodyend="129"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1ab9f913aa0d90a65e1b70dc0a939e041c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Table&lt; P, R, H &gt;::dump_table</definition>
        <argsstring>() const</argsstring>
        <name>dump_table</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="131" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1a3633b7419edf39e46aaeeef580171d36" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Table&lt; P, R, H &gt;::dump_instances</definition>
        <argsstring>() const</argsstring>
        <name>dump_instances</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="133" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classTable_1aadcaa478e654b84bf4918d19701b8c99" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classRecord" kindref="compound">Record</ref>&lt; P &gt; *</type>
        <definition>Record&lt;P&gt;* Table&lt; P, R, H &gt;::getRecord</definition>
        <argsstring>(const P &amp;p, unsigned int state=0)</argsstring>
        <name>getRecord</name>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>state</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
<para>return an pointer to the table entry (record) for p; the entry is created if there is none. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>must be complete. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="157" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1af4b23fdb2f8a309b9293acfbce34c881" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::pair&lt; typename MapInstances&lt; P, H &gt;::iterator, typename MapInstances&lt; P, H &gt;::iterator &gt;</type>
        <definition>std::pair&lt;typename MapInstances&lt;P,H&gt;::iterator, typename MapInstances&lt;P,H&gt;::iterator&gt; Table&lt; P, R, H &gt;::getInstances</definition>
        <argsstring>(const P &amp;)</argsstring>
        <name>getInstances</name>
        <param>
          <type>const P &amp;</type>
        </param>
        <briefdescription>
<para>return a pair, whose first component is an iterator to the first instance of p registered and second component is an iterator to the end of the range of instances of p. The instances range between these two iterators, including pair::first, but not pair::second. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="168" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1af2e9de2f198f3dca31c20b676acda02b" prot="private" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool Table&lt; P, R, H &gt;::existsInstance</definition>
        <argsstring>(const P &amp;, const P &amp;) const</argsstring>
        <name>existsInstance</name>
        <param>
          <type>const P &amp;</type>
        </param>
        <param>
          <type>const P &amp;</type>
        </param>
        <briefdescription>
<para>if the pair (pp, pc) is registered in the instance table. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="171" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1af72819fddec2a6e52cc3b56824bff84b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t Table&lt; P, R, H &gt;::addComplete</definition>
        <argsstring>(const P &amp;p, Record&lt; P &gt; *it)</argsstring>
        <name>addComplete</name>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classRecord" kindref="compound">Record</ref>&lt; P &gt; *</type>
          <declname>it</declname>
        </param>
        <briefdescription>
<para>the record pointed by it (second param) has been updated (filled with all runs with target p) and can be asked for best run (or k-best runs). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>target pointer, must be complete, it must be an iterator to a pair associated to p in table (first component must be p). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>it</parametername>
</parameternamelist>
<parameterdescription>
<para>record to fill with runs rageting p. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="184" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1ab337a4e7f1b6535b7e10de6847cc120e" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t Table&lt; P, R, H &gt;::addPartial</definition>
        <argsstring>(const P &amp;p)</argsstring>
        <name>addPartial</name>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>table of instances is updated with all possible instances of p, and map table is updated with all runs for all these instances of p. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>must be partial. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="warning"><para>this must the first call to addPartial for p. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="191" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1a7a9a677adbd85df8410bfe6225ccd6ba" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t Table&lt; P, R, H &gt;::add</definition>
        <argsstring>(const P &amp;p, Record&lt; P &gt; *i)</argsstring>
        <name>add</name>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classRecord" kindref="compound">Record</ref>&lt; P &gt; *</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>Compute and add all complete runs with target p (or complete instances of p if p partial) to records associated to p (associated to all complete instances of p if p partial) using <ref refid="classWTA" kindref="compound">WTA</ref> transition table to compute these runs. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>can be complete or partial, </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>if p is complete then i must be a pointer to the record associated to p in table. otherwise it is NULL.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="warning"><para>must be called by addComplete or addPartial. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="205" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1af803f800eea202d3f0ae09b13f79475d" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Table&lt; P, R, H &gt;::newWTARun</definition>
        <argsstring>(const P &amp;p, Record&lt; P &gt; *i, state_t s)</argsstring>
        <name>newWTARun</name>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classRecord" kindref="compound">Record</ref>&lt; P &gt; *</type>
          <declname>i</declname>
        </param>
        <param>
          <type>state_t</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>subcase of add(p, i) for the case when p has <ref refid="classWTA" kindref="compound">WTA</ref> state s. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>must be called by add(p, it) </para>
</simplesect>
<xrefsect id="todo_1_todo000036"><xreftitle>Todo</xreftitle><xrefdescription><para>TBR </para>
</xrefdescription></xrefsect></para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="210" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1a98735d3fd249079bad4687d749c83c68" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Table&lt; P, R, H &gt;::newMetaRun</definition>
        <argsstring>(const P &amp;, Record&lt; P &gt; *, state_t s)</argsstring>
        <name>newMetaRun</name>
        <param>
          <type>const P &amp;</type>
        </param>
        <param>
          <type><ref refid="classRecord" kindref="compound">Record</ref>&lt; P &gt; *</type>
        </param>
        <param>
          <type>state_t</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>subcase of add(p, i) for the case when p has meta state s. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>must be called by add(p, it) </para>
</simplesect>
<xrefsect id="todo_1_todo000037"><xreftitle>Todo</xreftitle><xrefdescription><para>TBR </para>
</xrefdescription></xrefsect></para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="217" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1ae69b65f00f500e2530ed4737be7ea568" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t Table&lt; P, R, H &gt;::addTable</definition>
        <argsstring>(const P &amp;p, Run&lt; P &gt; *r, Record&lt; P &gt; *i)</argsstring>
        <name>addTable</name>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classRun" kindref="compound">Run</ref>&lt; P &gt; *</type>
          <declname>r</declname>
        </param>
        <param>
          <type><ref refid="classRecord" kindref="compound">Record</ref>&lt; P &gt; *</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>particular case of add(p, r, i) add r to the record in the given entry for p in the map table. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>must be complete. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>must be complete. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>i</parametername>
</parameternamelist>
<parameterdescription>
<para>must be an pointer to the entry for p in table. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="231" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1afb6612571eb59cafcc9daf77b0606dbc" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t Table&lt; P, R, H &gt;::addInstanciate</definition>
        <argsstring>(const P &amp;p, Run&lt; P &gt; *r)</argsstring>
        <name>addInstanciate</name>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classRun" kindref="compound">Run</ref>&lt; P &gt; *</type>
          <declname>r</declname>
        </param>
        <briefdescription>
<para>particular case of add(p, r, it) create the instance p&apos; of p defined by r, add r to the entry for p&apos; in the map table and add the pair (p, p&apos;) to the instance table. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>must be partial. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>must be complete. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if the run or one instance of the run (at least) was added to the table </para>
</simplesect>
<simplesect kind="return"><para>&gt; 0 otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="242" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1a7cecbbf4da981e5e147daf226077a2f6" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t Table&lt; P, R, H &gt;::addUpdate</definition>
        <argsstring>(const P &amp;p, Run&lt; P &gt; *r, Record&lt; P &gt; *it)</argsstring>
        <name>addUpdate</name>
        <param>
          <type>const P &amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type><ref refid="classRun" kindref="compound">Run</ref>&lt; P &gt; *</type>
          <declname>r</declname>
        </param>
        <param>
          <type><ref refid="classRecord" kindref="compound">Record</ref>&lt; P &gt; *</type>
          <declname>it</declname>
        </param>
        <briefdescription>
<para>particular case of add(p, r, it) add (to p&apos;s record) all possible complete updates of r (obtained by replacing the partial ptr in r by a complete instance). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>must be complete. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>must be partial. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>it</parametername>
</parameternamelist>
<parameterdescription>
<para>must be an iterator to the entry for p in table. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if the run or one instance of the run (at least) was added to the table </para>
</simplesect>
<simplesect kind="return"><para>&gt; 0 otherwise </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="253" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classTable_1a4cd04680d74f547f37568c4ab3e0cc51" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void Table&lt; P, R, H &gt;::addInstance</definition>
        <argsstring>(const P &amp;pp, const P &amp;pc)</argsstring>
        <name>addInstance</name>
        <param>
          <type>const P &amp;</type>
          <declname>pp</declname>
        </param>
        <param>
          <type>const P &amp;</type>
          <declname>pc</declname>
        </param>
        <briefdescription>
<para>add(pp, pc) create a record it associated to pc in table and add the pair &lt;pp, it&gt; to the table of instances . </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pp</parametername>
</parameternamelist>
<parameterdescription>
<para>must be partial. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pc</parametername>
</parameternamelist>
<parameterdescription>
<para>must be complete, pc must be an instance of pp, pc must not be registered in table. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/table/Table.hpp" line="263" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>parse table. </para>
    </briefdescription>
    <detaileddescription>
<para>table defines two main undorered mappings:</para>
<para>map table: <programlisting><codeline><highlight class="normal">map<sp/>key<sp/>-&gt;<sp/>value<sp/></highlight></codeline>
</programlisting> where<itemizedlist>
<listitem><para>key of type P = <ref refid="classPointer" kindref="compound">Pointer</ref></para>
</listitem><listitem><para>value of type R = <ref refid="classRecord" kindref="compound">Record</ref></para>
</listitem></itemizedlist>
</para>
<para>(stores some <ref refid="classRun" kindref="compound">Run</ref></para>
<para>*)<itemizedlist>
<listitem><para>H = Hasher for P</para>
</listitem><listitem><para>equal+to is op. == defined in P</para>
</listitem></itemizedlist>
</para>
<para>table of instances: <programlisting><codeline><highlight class="normal">multimap:<sp/>key<sp/>-&gt;<sp/>keys<sp/></highlight></codeline>
</programlisting> where<itemizedlist>
<listitem><para>key of type P = <ref refid="classPointer" kindref="compound">Pointer</ref> (partial)</para>
</listitem><listitem><para>keys of type P = complete <ref refid="classPointer" kindref="compound">Pointer</ref> instances of key</para>
</listitem><listitem><para>H = Hasher for P</para>
</listitem><listitem><para>equal+to is op. == defined in P </para>
</listitem></itemizedlist>
</para>
    </detaileddescription>
    <inheritancegraph>
      <node id="455">
        <label>Atable&lt; P &gt;</label>
        <link refid="classAtable"/>
      </node>
      <node id="454">
        <label>Table&lt; P, R, H &gt;</label>
        <link refid="classTable"/>
        <childnode refid="455" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="457">
        <label>Atable&lt; P &gt;</label>
        <link refid="classAtable"/>
      </node>
      <node id="456">
        <label>Table&lt; P, R, H &gt;</label>
        <link refid="classTable"/>
        <childnode refid="457" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="src/table/Table.hpp" line="66" column="1" bodyfile="src/table/Table.hpp" bodystart="65" bodyend="266"/>
    <listofallmembers>
      <member refid="classAtable_1a84214b2c984a18a8cec13313152d3eaa" prot="protected" virt="non-virtual"><scope>Table</scope><name>_comparer</name></member>
      <member refid="classTable_1a0b1dce071cf54f33fde24854ef373c06" prot="private" virt="non-virtual"><scope>Table</scope><name>_instances</name></member>
      <member refid="classTable_1a7298de4734f3bc98c30407a08fe5671b" prot="private" virt="non-virtual"><scope>Table</scope><name>_nb_rows</name></member>
      <member refid="classTable_1a298e3a396f9cc2decc08b0f9801c1bc2" prot="private" virt="non-virtual"><scope>Table</scope><name>_nb_runs</name></member>
      <member refid="classTable_1a5a8b25168c3af6596d29ac4dbbaa0650" prot="private" virt="non-virtual"><scope>Table</scope><name>_table</name></member>
      <member refid="classTable_1a69ccf554edee39f61692c26a3b4667e1" prot="public" virt="non-virtual"><scope>Table</scope><name>add</name></member>
      <member refid="classTable_1a9231e3b8782acfabbafe1f1dcb85a3bb" prot="public" virt="virtual"><scope>Table</scope><name>add</name></member>
      <member refid="classTable_1a7a9a677adbd85df8410bfe6225ccd6ba" prot="private" virt="non-virtual"><scope>Table</scope><name>add</name></member>
      <member refid="classTable_1af72819fddec2a6e52cc3b56824bff84b" prot="private" virt="non-virtual"><scope>Table</scope><name>addComplete</name></member>
      <member refid="classTable_1a4cd04680d74f547f37568c4ab3e0cc51" prot="private" virt="non-virtual"><scope>Table</scope><name>addInstance</name></member>
      <member refid="classTable_1afb6612571eb59cafcc9daf77b0606dbc" prot="private" virt="non-virtual"><scope>Table</scope><name>addInstanciate</name></member>
      <member refid="classTable_1ab337a4e7f1b6535b7e10de6847cc120e" prot="private" virt="non-virtual"><scope>Table</scope><name>addPartial</name></member>
      <member refid="classTable_1ae69b65f00f500e2530ed4737be7ea568" prot="private" virt="non-virtual"><scope>Table</scope><name>addTable</name></member>
      <member refid="classTable_1a7cecbbf4da981e5e147daf226077a2f6" prot="private" virt="non-virtual"><scope>Table</scope><name>addUpdate</name></member>
      <member refid="classAtable_1ad519343a13265a31ba1d0951be0e3185" prot="public" virt="non-virtual"><scope>Table</scope><name>Atable</name></member>
      <member refid="classTable_1a2e8c9b5856741684b1ec7d8fc640cc81" prot="public" virt="virtual"><scope>Table</scope><name>best</name></member>
      <member refid="classTable_1ace006d9777eee7bb4835f821bc5c9467" prot="public" virt="virtual"><scope>Table</scope><name>bestTree</name></member>
      <member refid="classTable_1a53788fcf01e286097b3c0d7c7573d61f" prot="public" virt="virtual"><scope>Table</scope><name>bestTree</name></member>
      <member refid="classTable_1a3633b7419edf39e46aaeeef580171d36" prot="public" virt="non-virtual"><scope>Table</scope><name>dump_instances</name></member>
      <member refid="classTable_1ab9f913aa0d90a65e1b70dc0a939e041c" prot="public" virt="non-virtual"><scope>Table</scope><name>dump_table</name></member>
      <member refid="classTable_1af2e9de2f198f3dca31c20b676acda02b" prot="private" virt="non-virtual"><scope>Table</scope><name>existsInstance</name></member>
      <member refid="classTable_1af4b23fdb2f8a309b9293acfbce34c881" prot="private" virt="non-virtual"><scope>Table</scope><name>getInstances</name></member>
      <member refid="classTable_1aadcaa478e654b84bf4918d19701b8c99" prot="private" virt="non-virtual"><scope>Table</scope><name>getRecord</name></member>
      <member refid="classTable_1aea047b02e7a9f2d714248903f52f5722" prot="public" virt="virtual"><scope>Table</scope><name>nb_entries</name></member>
      <member refid="classTable_1a8e4b509c921bf151b3601fca7704aaee" prot="public" virt="virtual"><scope>Table</scope><name>nb_runs</name></member>
      <member refid="classTable_1a98735d3fd249079bad4687d749c83c68" prot="private" virt="non-virtual"><scope>Table</scope><name>newMetaRun</name></member>
      <member refid="classTable_1af803f800eea202d3f0ae09b13f79475d" prot="private" virt="non-virtual"><scope>Table</scope><name>newWTARun</name></member>
      <member refid="classAtable_1a43c761e5718010983659d7162f89d8d3" prot="public" virt="non-virtual"><scope>Table</scope><name>parent</name></member>
      <member refid="classTable_1a75c05943dcc9afb9ee0af010143a692e" prot="public" virt="non-virtual"><scope>Table</scope><name>Table</name></member>
      <member refid="classAtable_1a535587360990ee5a9351501739585f13" prot="public" virt="non-virtual"><scope>Table</scope><name>~Atable</name></member>
      <member refid="classTable_1a589746398a8320b124a5b19f37b9851f" prot="public" virt="non-virtual"><scope>Table</scope><name>~Table</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
