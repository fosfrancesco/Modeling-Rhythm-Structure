<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.15">
  <compounddef id="classAlignedInterval" kind="class" language="C++" prot="public">
    <compoundname>AlignedInterval</compoundname>
    <basecompoundref refid="classInterval" prot="public" virt="non-virtual">Interval</basecompoundref>
    <derivedcompoundref refid="classIntervalTree" prot="public" virt="non-virtual">IntervalTree</derivedcompoundref>
    <includes local="no">AlignedInterval.hpp</includes>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classAlignedInterval_1ac157527bf2349e36ef2475096d268e4e" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class IntervalHeap</definition>
        <argsstring></argsstring>
        <name>IntervalHeap</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="36" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classAlignedInterval_1a08c62a5a4c60368e97b1385aced32756" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend std::ostream &amp;</type>
        <definition>std::ostream&amp; operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;, const AlignedInterval &amp;)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <defname>o</defname>
        </param>
        <param>
          <type>const <ref refid="classAlignedInterval" kindref="compound">AlignedInterval</ref> &amp;</type>
          <defname>p</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="168" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="294" bodyend="324"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classAlignedInterval_1ae30ff91f501aebc7f5205a4235207c7f" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t AlignedInterval::_seg_llen</definition>
        <argsstring></argsstring>
        <name>_seg_llen</name>
        <briefdescription>
<para>number of elements of input segment in the first half of this interval. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="189" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="189" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classAlignedInterval_1a49fb3c372a6c573bd0656236a38571d2" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t AlignedInterval::_seg_lbeg</definition>
        <argsstring></argsstring>
        <name>_seg_lbeg</name>
        <briefdescription>
<para>index of the first element of input segment inside the fist half of this interval or out_of_range (= size of segment) is there are none. </para>
        </briefdescription>
        <detaileddescription>
<para>zero if alignment has not been computed for this interval. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="196" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="196" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classAlignedInterval_1afa5f0c3d013b9823eb74a3764ba45f61" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t AlignedInterval::_seg_rlen</definition>
        <argsstring></argsstring>
        <name>_seg_rlen</name>
        <briefdescription>
<para>number of elements of input segment in the second half of this interval. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="200" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="200" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classAlignedInterval_1a34764e69ef297f9b2517c158afec6166" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t AlignedInterval::_seg_rbeg</definition>
        <argsstring></argsstring>
        <name>_seg_rbeg</name>
        <briefdescription>
<para>index of the first element of input segment inside the second half of this interval or out_of_range (= size of segment) is there are none. </para>
        </briefdescription>
        <detaileddescription>
<para>zero if alignment has not been computed for this interval. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="207" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="207" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classAlignedInterval_1ae568a5e8c795b6465053e5fd2c494e58" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t AlignedInterval::_seg_next</definition>
        <argsstring></argsstring>
        <name>_seg_next</name>
        <briefdescription>
<para>index of the first element of input segment ouside this interval (= after the right bound) or out_of_bound (= segment size) is there are none. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="212" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="212" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classAlignedInterval_1adf6d0cf7e419261f9b92df6c85a46510" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t AlignedInterval::_seg_first</definition>
        <argsstring></argsstring>
        <name>_seg_first</name>
        <briefdescription>
<para>index of the first element of input segment after the right bound of this interval (i.e. inside or after this interval). </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="217" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="217" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="group__segment_1ga7e9399ce64bb21aa2d2c3cd682ca95da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>AlignedInterval::AlignedInterval</definition>
        <argsstring>(const InputSegment *s, Rational mend=Rational(1), bool f_align=false)</argsstring>
        <name>AlignedInterval</name>
        <param>
          <type>const <ref refid="classInputSegment" kindref="compound">InputSegment</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type><ref refid="classRational" kindref="compound">Rational</ref></type>
          <declname>mend</declname>
          <defval><ref refid="classRational" kindref="compound">Rational</ref>(1)</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>f_align</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para><ref refid="classInterval" kindref="compound">Interval</ref> covering the whole length of the given input segment with given musical time length (number of bars). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>given input segment </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mend</parametername>
</parameternamelist>
<parameterdescription>
<para>given musical time length </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f_align</parametername>
</parameternamelist>
<parameterdescription>
<para>flag says wether alignement must be computed for the interval. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="48" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="16" bodyend="32"/>
      </memberdef>
      <memberdef kind="function" id="group__segment_1ga5bf2bf3fe1a1791989ec52969aace0a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>AlignedInterval::AlignedInterval</definition>
        <argsstring>(const AlignedInterval &amp;)</argsstring>
        <name>AlignedInterval</name>
        <param>
          <type>const <ref refid="classAlignedInterval" kindref="compound">AlignedInterval</ref> &amp;</type>
          <defname>p</defname>
        </param>
        <briefdescription>
<para>copy. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="71" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="57" bodyend="65"/>
      </memberdef>
      <memberdef kind="function" id="classAlignedInterval_1ae327b28af603aaffbe9bc8480c6e2109" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>AlignedInterval::~AlignedInterval</definition>
        <argsstring>()</argsstring>
        <name>~AlignedInterval</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>do not deallocate the segment here. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="74" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="74" bodyend="74"/>
      </memberdef>
      <memberdef kind="function" id="group__segment_1ga304aac2ec620d785bbfb67996a7a613b" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type><ref refid="classAlignedInterval" kindref="compound">AlignedInterval</ref> &amp;</type>
        <definition>AlignedInterval &amp; AlignedInterval::operator=</definition>
        <argsstring>(const AlignedInterval &amp;)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classAlignedInterval" kindref="compound">AlignedInterval</ref> &amp;</type>
          <defname>p</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="76" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="68" bodyend="81"/>
      </memberdef>
      <memberdef kind="function" id="group__segment_1ga40f7de6ee8d8b73172ca1dbfa54bfe62" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type>bool</type>
        <definition>bool AlignedInterval::operator==</definition>
        <argsstring>(const AlignedInterval &amp;) const</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classAlignedInterval" kindref="compound">AlignedInterval</ref> &amp;</type>
          <defname>p</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="78" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="84" bodyend="96"/>
      </memberdef>
      <memberdef kind="function" id="classAlignedInterval_1a260f8eead747a05642d7b5d720d02e5b" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AlignedInterval::lsize</definition>
        <argsstring>() const</argsstring>
        <name>lsize</name>
        <briefdescription>
<para>number of elements of input segment in the first half of this interval. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>the interval must have been aligned. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="84" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="84" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="classAlignedInterval_1a85114f9883305f0cf975dbdffff41772" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AlignedInterval::lfirst</definition>
        <argsstring>() const</argsstring>
        <name>lfirst</name>
        <briefdescription>
<para>index of the first element of input segment inside the fist half of this interval. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>out_of_range (= size of segment) if l_size() == 0. </para>
</simplesect>
<simplesect kind="warning"><para>the interval must have been aligned. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="91" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="91" bodyend="91"/>
      </memberdef>
      <memberdef kind="function" id="classAlignedInterval_1abf3b5daa25e0d74999e5a2d1d04cd185" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AlignedInterval::rsize</definition>
        <argsstring>() const</argsstring>
        <name>rsize</name>
        <briefdescription>
<para>number of elements of input segment in the second half of this interval. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>the interval must have been aligned. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="97" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="97" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="classAlignedInterval_1aa7c4a66d5fd0ff2dc29a4fea57f0c561" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AlignedInterval::rfirst</definition>
        <argsstring>() const</argsstring>
        <name>rfirst</name>
        <briefdescription>
<para>index of the first element of input segment inside the second half of this interval. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>out_of_range (= size of segment) if r_size() == 0. </para>
</simplesect>
<simplesect kind="warning"><para>the interval must have been aligned. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="104" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="104" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="classAlignedInterval_1aacfe86f36bfd28f6a56c7a673ed7dad7" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AlignedInterval::size</definition>
        <argsstring>() const</argsstring>
        <name>size</name>
        <briefdescription>
<para>number of elements of input segment in this interval. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>the interval must have been aligned. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="109" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="109" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="classAlignedInterval_1a1660736ae6e829e6c92616e49784a583" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AlignedInterval::first</definition>
        <argsstring>() const</argsstring>
        <name>first</name>
        <briefdescription>
<para>index of the first element of input segment after the right bound of this interval (i.e. inside or after this interval). </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>out_of_range (= size of segment) if there is none. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="117" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="117" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="classAlignedInterval_1ac9617c302c66993c1f84c757f2c71d16" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AlignedInterval::next</definition>
        <argsstring>() const</argsstring>
        <name>next</name>
        <briefdescription>
<para>index of the first element of input segment ouside this interval (= after the right bound). </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>out_of_range (= size of segment) if there is none. </para>
</simplesect>
<simplesect kind="warning"><para>the interval must have been aligned. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="124" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="124" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="classAlignedInterval_1adefeebb5ddd10a68e83ed7382626d380" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool AlignedInterval::inhabited</definition>
        <argsstring>() const</argsstring>
        <name>inhabited</name>
        <briefdescription>
<para>this interval contains at least an element of the input segment </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>the interval must have been aligned. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="129" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="129" bodyend="130"/>
      </memberdef>
      <memberdef kind="function" id="group__segment_1ga25f42094dbb3623c73df11dd85596185" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AlignedInterval::align</definition>
        <argsstring>(const InputSegment *s, size_t b)</argsstring>
        <name>align</name>
        <param>
          <type>const <ref refid="classInputSegment" kindref="compound">InputSegment</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>set the alignment parameters, starting from index b of input segment point and return the next index of point in input segment to be processed (first index at right of this interval) or the size of input segment (total # points) if end of segment is reached. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>input segment processed </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>must be the index of a segment&apos;s point. it must be after the left bound of the interval (begin). it can be out of the interval, i.e. after the right bound (end). _seg_first is replaced by b.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="warning"><para>The realtime begin date of this interval can be out of the input segment bounds. </para>
</simplesect>
<simplesect kind="warning"><para>The realtime end date of this interval can be out of the input segment bounds. In the later case, alignement is done like the input segment is padded with empty space up to the end of this interval. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="150" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="105" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="group__segment_1ga85de404c4ddf91a51bf0c29c6dbe1d77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AlignedInterval::align</definition>
        <argsstring>(const InputSegment *s)</argsstring>
        <name>align</name>
        <param>
          <type>const <ref refid="classInputSegment" kindref="compound">InputSegment</ref> *</type>
          <declname>s</declname>
        </param>
        <briefdescription>
<para>same as previous but uses _seg_first instead of argument b. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="153" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="113" bodyend="211"/>
      </memberdef>
      <memberdef kind="function" id="group__segment_1gafad6a7eea9e5892cfae9986f6263a738" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AlignedInterval::rewind</definition>
        <argsstring>(const InputSegment *s, size_t b)</argsstring>
        <name>rewind</name>
        <param>
          <type>const <ref refid="classInputSegment" kindref="compound">InputSegment</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>b</declname>
        </param>
        <briefdescription>
<para>compute only the value of the next point (the first element of input segment after the right bound of this interval) starting from index b of input segment point. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>same preconditions on b as for align. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="160" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="214" bodyend="218"/>
      </memberdef>
      <memberdef kind="function" id="group__segment_1ga1a6a8f006c2d11e8f4af7250a6fb0b16" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t AlignedInterval::rewind</definition>
        <argsstring>(const InputSegment *)</argsstring>
        <name>rewind</name>
        <param>
          <type>const <ref refid="classInputSegment" kindref="compound">InputSegment</ref> *</type>
          <defname>s</defname>
        </param>
        <briefdescription>
<para>same as previous but uses _seg_first instead of arg. b. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="163" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="222" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="group__segment_1gaeb6593290d19ff04137c3f3c3e9e3175" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool AlignedInterval::aligned</definition>
        <argsstring>() const</argsstring>
        <name>aligned</name>
        <briefdescription>
<para>this interval has been aligned. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="166" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="99" bodyend="102"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="group__segment_1ga4aa5548293e2dcd94ab3845d9a8fe492" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>AlignedInterval::AlignedInterval</definition>
        <argsstring>(const InputSegment *s, Rational mbeg, Rational mend, double rbeg, double rend, size_t first, bool f_align=false)</argsstring>
        <name>AlignedInterval</name>
        <param>
          <type>const <ref refid="classInputSegment" kindref="compound">InputSegment</ref> *</type>
          <declname>s</declname>
        </param>
        <param>
          <type><ref refid="classRational" kindref="compound">Rational</ref></type>
          <declname>mbeg</declname>
        </param>
        <param>
          <type><ref refid="classRational" kindref="compound">Rational</ref></type>
          <declname>mend</declname>
        </param>
        <param>
          <type>double</type>
          <declname>rbeg</declname>
        </param>
        <param>
          <type>double</type>
          <declname>rend</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>first</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>f_align</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>aligned interval with musical-time bounds [mbegin, mbegin+mdur[ and real-time bounds [rbegin, rbegin+rdur[ for the input segment s. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>must be the first element of input segment after the beginning of this interval.</para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f_align</parametername>
</parameternamelist>
<parameterdescription>
<para>flag says wether alignement must be computed for the interval. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="180" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="36" bodyend="54"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="group__segment_1ga0be5d430ebcf64f2789eb37886b16367" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool AlignedInterval::_check_first</definition>
        <argsstring>(const InputSegment *)</argsstring>
        <name>_check_first</name>
        <param>
          <type>const <ref refid="classInputSegment" kindref="compound">InputSegment</ref> *</type>
          <defname>s</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="219" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="250" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="group__segment_1ga427dfea0ea3968e99fb4f59ff462a378" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool AlignedInterval::_check_next</definition>
        <argsstring>(const InputSegment *)</argsstring>
        <name>_check_next</name>
        <param>
          <type>const <ref refid="classInputSegment" kindref="compound">InputSegment</ref> *</type>
          <defname>s</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/segment/AlignedInterval.hpp" line="221" column="1" bodyfile="src/segment/AlignedInterval.cpp" bodystart="272" bodyend="291"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Extension of <ref refid="classInterval" kindref="compound">Interval</ref> with computed alignment of <ref refid="classInputSegment" kindref="compound">InputSegment</ref> points onto left- and right-bounds. </para>
    </briefdescription>
    <detaileddescription>
<para>The result of aligment can be consulted with function l/rsize, l/rfirst. alignement is computed by function align.</para>
<para>The alignement is computed automatically for newly created intervals, the other created intervals (multiple-bars intervals) are not aligned. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>Interval</label>
        <link refid="classInterval"/>
      </node>
      <node id="0">
        <label>AlignedInterval</label>
        <link refid="classAlignedInterval"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>IntervalTree</label>
        <link refid="classIntervalTree"/>
        <childnode refid="0" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="4">
        <label>Interval</label>
        <link refid="classInterval"/>
        <childnode refid="5" relation="usage">
          <edgelabel>mbegin</edgelabel>
          <edgelabel>mend</edgelabel>
        </childnode>
      </node>
      <node id="3">
        <label>AlignedInterval</label>
        <link refid="classAlignedInterval"/>
        <childnode refid="4" relation="public-inheritance">
        </childnode>
      </node>
      <node id="5">
        <label>Rational</label>
        <link refid="classRational"/>
      </node>
    </collaborationgraph>
    <location file="src/segment/AlignedInterval.hpp" line="35" column="1" bodyfile="src/segment/AlignedInterval.hpp" bodystart="34" bodyend="223"/>
    <listofallmembers>
      <member refid="group__segment_1ga0be5d430ebcf64f2789eb37886b16367" prot="private" virt="non-virtual"><scope>AlignedInterval</scope><name>_check_first</name></member>
      <member refid="group__segment_1ga427dfea0ea3968e99fb4f59ff462a378" prot="private" virt="non-virtual"><scope>AlignedInterval</scope><name>_check_next</name></member>
      <member refid="classAlignedInterval_1adf6d0cf7e419261f9b92df6c85a46510" prot="private" virt="non-virtual"><scope>AlignedInterval</scope><name>_seg_first</name></member>
      <member refid="classAlignedInterval_1a49fb3c372a6c573bd0656236a38571d2" prot="private" virt="non-virtual"><scope>AlignedInterval</scope><name>_seg_lbeg</name></member>
      <member refid="classAlignedInterval_1ae30ff91f501aebc7f5205a4235207c7f" prot="private" virt="non-virtual"><scope>AlignedInterval</scope><name>_seg_llen</name></member>
      <member refid="classAlignedInterval_1ae568a5e8c795b6465053e5fd2c494e58" prot="private" virt="non-virtual"><scope>AlignedInterval</scope><name>_seg_next</name></member>
      <member refid="classAlignedInterval_1a34764e69ef297f9b2517c158afec6166" prot="private" virt="non-virtual"><scope>AlignedInterval</scope><name>_seg_rbeg</name></member>
      <member refid="classAlignedInterval_1afa5f0c3d013b9823eb74a3764ba45f61" prot="private" virt="non-virtual"><scope>AlignedInterval</scope><name>_seg_rlen</name></member>
      <member refid="group__segment_1ga25f42094dbb3623c73df11dd85596185" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>align</name></member>
      <member refid="group__segment_1ga85de404c4ddf91a51bf0c29c6dbe1d77" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>align</name></member>
      <member refid="group__segment_1gaeb6593290d19ff04137c3f3c3e9e3175" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>aligned</name></member>
      <member refid="group__segment_1ga7e9399ce64bb21aa2d2c3cd682ca95da" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>AlignedInterval</name></member>
      <member refid="group__segment_1ga5bf2bf3fe1a1791989ec52969aace0a5" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>AlignedInterval</name></member>
      <member refid="group__segment_1ga4aa5548293e2dcd94ab3845d9a8fe492" prot="protected" virt="non-virtual"><scope>AlignedInterval</scope><name>AlignedInterval</name></member>
      <member refid="classAlignedInterval_1a1660736ae6e829e6c92616e49784a583" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>first</name></member>
      <member refid="classAlignedInterval_1adefeebb5ddd10a68e83ed7382626d380" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>inhabited</name></member>
      <member refid="group__segment_1ga3af4cc83b5ee3d320fa5b24fa244fabb" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>insideBar</name></member>
      <member refid="group__segment_1gadfaf31fca3f5e5da49e37c7baa275125" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>Interval</name></member>
      <member refid="group__segment_1ga17cfcca410ae94fe906dfcdb726026f5" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>Interval</name></member>
      <member refid="group__segment_1ga43e7da7f24dfa17fccdd0dd40a96f458" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>Interval</name></member>
      <member refid="group__segment_1gaefc21b7c838661c05286304f6d891690" prot="protected" virt="non-virtual"><scope>AlignedInterval</scope><name>Interval</name></member>
      <member refid="classAlignedInterval_1ac157527bf2349e36ef2475096d268e4e" prot="private" virt="non-virtual"><scope>AlignedInterval</scope><name>IntervalHeap</name></member>
      <member refid="classAlignedInterval_1a85114f9883305f0cf975dbdffff41772" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>lfirst</name></member>
      <member refid="classAlignedInterval_1a260f8eead747a05642d7b5d720d02e5b" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>lsize</name></member>
      <member refid="classInterval_1a6c8385bc5875cb761827f9e75f783834" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>mbegin</name></member>
      <member refid="classInterval_1aaed8b0e404390af39c51e657636bf14d" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>mduration</name></member>
      <member refid="classInterval_1a963b9b36f085a7db9c159c55608f8408" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>mend</name></member>
      <member refid="classAlignedInterval_1ac9617c302c66993c1f84c757f2c71d16" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>next</name></member>
      <member refid="classAlignedInterval_1a08c62a5a4c60368e97b1385aced32756" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>operator&lt;&lt;</name></member>
      <member refid="group__segment_1ga304aac2ec620d785bbfb67996a7a613b" prot="public" virt="virtual"><scope>AlignedInterval</scope><name>operator=</name></member>
      <member refid="group__segment_1ga6508f58e15c54be6146d5505d91a4b91" prot="public" virt="virtual" ambiguityscope="Interval::"><scope>AlignedInterval</scope><name>operator=</name></member>
      <member refid="group__segment_1ga40f7de6ee8d8b73172ca1dbfa54bfe62" prot="public" virt="virtual"><scope>AlignedInterval</scope><name>operator==</name></member>
      <member refid="group__segment_1ga4b0896bf3843fec18d68a130fe9a49f6" prot="public" virt="virtual" ambiguityscope="Interval::"><scope>AlignedInterval</scope><name>operator==</name></member>
      <member refid="classInterval_1aa17f339b42a23f6afc188971e7003d84" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>rbegin</name></member>
      <member refid="classInterval_1afbb05608fd0b263d905a29480e921b75" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>rduration</name></member>
      <member refid="classInterval_1a1acb3128311a318b23e68cc8ca0182e9" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>rend</name></member>
      <member refid="group__segment_1gafad6a7eea9e5892cfae9986f6263a738" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>rewind</name></member>
      <member refid="group__segment_1ga1a6a8f006c2d11e8f4af7250a6fb0b16" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>rewind</name></member>
      <member refid="classAlignedInterval_1aa7c4a66d5fd0ff2dc29a4fea57f0c561" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>rfirst</name></member>
      <member refid="classAlignedInterval_1abf3b5daa25e0d74999e5a2d1d04cd185" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>rsize</name></member>
      <member refid="classAlignedInterval_1aacfe86f36bfd28f6a56c7a673ed7dad7" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>size</name></member>
      <member refid="classAlignedInterval_1ae327b28af603aaffbe9bc8480c6e2109" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>~AlignedInterval</name></member>
      <member refid="classInterval_1a923e1717a3dedfe1ba90f81fcb26d5c5" prot="public" virt="non-virtual"><scope>AlignedInterval</scope><name>~Interval</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
