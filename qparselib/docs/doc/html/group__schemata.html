<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>qparse: Schemata module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">qparse
   </div>
   <div id="projectbrief">library for music transcription by parsing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Schemata module</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <code>schemata</code> module contains classes of weighted tree automata used for parsing.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceState"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceState.html">State</a></td></tr>
<tr class="memdesc:namespaceState"><td class="mdescLeft">&#160;</td><td class="mdescRight">States. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComboState.html">ComboState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tmp state structure for construction of <a class="el" href="classComboWTA.html" title="WTA combo: A special kind of WTA for quantization constructed from.">ComboWTA</a> from a <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> (base schema) and an input segment casted into state_t after construction  <a href="classComboState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structComboStateHasher.html">ComboStateHasher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComboWTA.html">ComboWTA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> combo: A special kind of <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> for quantization constructed from.  <a href="classComboWTA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCountingWTA.html">CountingWTA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy of <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> dedicated to corpus statistics.  <a href="classCountingWTA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreState.html">PreState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tmp state structure for construction of <a class="el" href="classPreWTA.html" title="extension of WTA where states are associated pre and post values.">PreWTA</a> from a <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> (base schema) casted aka state_t after construction  <a href="classPreState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreWTA.html">PreWTA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">extension of <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> where states are associated pre and post values.  <a href="classPreWTA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAONode.html">AONode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AND-OR alternating nested lists used by Adrien in RQ.  <a href="classAONode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classANode.html">ANode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classONode.html">ONode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structds__transition.html">ds_transition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dag schema  <a href="structds__transition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdagSchema.html">dagSchema</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dag whose edges are labeled by arity values two distinguished nodes:  <a href="classdagSchema.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransition.html">Transition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a <a class="el" href="classTransition.html" title="a Transition is defined by a sequence of antecedent states (body) the weight must be not null (null w...">Transition</a> is defined by a sequence of antecedent states (body) the weight must be not null (null weight means a missing transition).  <a href="classTransition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueState.html">ValueState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structValueStateHasher.html">ValueStateHasher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classValueWTA.html">ValueWTA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> is a special kind of <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> associated to an initial <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> (schema) and a rhythmic value (<a class="el" href="classDurationList.html" title="list of rational durations to label nodes of WTA Runs for Kbest enum.">DurationList</a>).  <a href="classValueWTA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransitionList.html">TransitionList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWTA.html">WTA</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class of schemas = weighted tree automata = weighted CFG.  <a href="classWTA.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDepthMarking.html">DepthMarking</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">marking of states of a <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> with informations on the depth of their occurences initialized with a <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a>, can be interrogated afterwards  <a href="classDepthMarking.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5f54dbbcb6e551cd56a12c9d9711f82e"><td class="memItemLeft" align="right" valign="top"><a id="ga5f54dbbcb6e551cd56a12c9d9711f82e"></a>
typedef std::unordered_map&lt; <a class="el" href="classComboState.html">ComboState</a>, state_t, <a class="el" href="structComboStateHasher.html">ComboStateHasher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Combomap</b></td></tr>
<tr class="separator:ga5f54dbbcb6e551cd56a12c9d9711f82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34fd7500c532fc3af1419927d6102bb4"><td class="memItemLeft" align="right" valign="top"><a id="ga34fd7500c532fc3af1419927d6102bb4"></a>
typedef std::set&lt; std::pair&lt; state_t, <a class="el" href="classTransition.html">Transition</a> &amp; &gt;, bool(*)(std::pair&lt; state_t, <a class="el" href="classTransition.html">Transition</a> &amp; &gt;, std::pair&lt; state_t, <a class="el" href="classTransition.html">Transition</a> &amp; &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga34fd7500c532fc3af1419927d6102bb4">OTransitionTable</a></td></tr>
<tr class="memdesc:ga34fd7500c532fc3af1419927d6102bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">transtition table ordered by transition's ids <br /></td></tr>
<tr class="separator:ga34fd7500c532fc3af1419927d6102bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0a920032a3757e491c0f765beb9657"><td class="memItemLeft" align="right" valign="top"><a id="gabd0a920032a3757e491c0f765beb9657"></a>
typedef long&#160;</td><td class="memItemRight" valign="bottom"><b>state_t</b></td></tr>
<tr class="separator:gabd0a920032a3757e491c0f765beb9657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb03191d1927740d0f6f55d525eec2be"><td class="memItemLeft" align="right" valign="top"><a id="gacb03191d1927740d0f6f55d525eec2be"></a>
typedef std::vector&lt; state_t &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>Transition_iterator</b></td></tr>
<tr class="separator:gacb03191d1927740d0f6f55d525eec2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada53f8336fc15b6740d915faaa812651"><td class="memItemLeft" align="right" valign="top"><a id="gada53f8336fc15b6740d915faaa812651"></a>
typedef std::vector&lt; state_t &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>Transition_const_iterator</b></td></tr>
<tr class="separator:gada53f8336fc15b6740d915faaa812651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga881b5f6757c004ef80638824b4057ad3"><td class="memItemLeft" align="right" valign="top"><a id="ga881b5f6757c004ef80638824b4057ad3"></a>
typedef std::unordered_map&lt; <a class="el" href="classValueState.html">ValueState</a>, state_t, <a class="el" href="structValueStateHasher.html">ValueStateHasher</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Valuemap</b></td></tr>
<tr class="separator:ga881b5f6757c004ef80638824b4057ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f065672b84540dc2310cee57062b5d"><td class="memItemLeft" align="right" valign="top"><a id="gaf9f065672b84540dc2310cee57062b5d"></a>
typedef std::list&lt; <a class="el" href="classTransition.html">Transition</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>TransitionList_iterator</b></td></tr>
<tr class="separator:gaf9f065672b84540dc2310cee57062b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a3bf271d488fbc785617cb246215f3"><td class="memItemLeft" align="right" valign="top"><a id="gac6a3bf271d488fbc785617cb246215f3"></a>
typedef std::list&lt; <a class="el" href="classTransition.html">Transition</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>TransitionList_const_iterator</b></td></tr>
<tr class="separator:gac6a3bf271d488fbc785617cb246215f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaacfb8dd676081cbdacc586bd08ef5339"><td class="memItemLeft" align="right" valign="top"><a id="gaacfb8dd676081cbdacc586bd08ef5339"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, const <a class="el" href="classComboState.html">ComboState</a> &amp;cs)</td></tr>
<tr class="separator:gaacfb8dd676081cbdacc586bd08ef5339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5876dc1d6e1700ecd64b79abc371f852"><td class="memItemLeft" align="right" valign="top"><a id="ga5876dc1d6e1700ecd64b79abc371f852"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>trcomp</b> (std::pair&lt; state_t, <a class="el" href="classTransition.html">Transition</a> &amp;&gt; lhs, std::pair&lt; state_t, <a class="el" href="classTransition.html">Transition</a> &amp;&gt; rhs)</td></tr>
<tr class="separator:ga5876dc1d6e1700ecd64b79abc371f852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf522606427f33e50d5ccd45945e140ac"><td class="memItemLeft" align="right" valign="top"><a id="gaf522606427f33e50d5ccd45945e140ac"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, const <a class="el" href="classCountingWTA.html">CountingWTA</a> &amp;a)</td></tr>
<tr class="separator:gaf522606427f33e50d5ccd45945e140ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8b99aabcea05e6f7f8b31da07ee3790"><td class="memItemLeft" align="right" valign="top"><a id="gaf8b99aabcea05e6f7f8b31da07ee3790"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, const <a class="el" href="classPreState.html">PreState</a> &amp;ps)</td></tr>
<tr class="separator:gaf8b99aabcea05e6f7f8b31da07ee3790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bf0c703002e360545ebd943f933fb18"><td class="memItemLeft" align="right" valign="top"><a id="ga9bf0c703002e360545ebd943f933fb18"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, const <a class="el" href="classPreWTA.html">PreWTA</a> &amp;a)</td></tr>
<tr class="separator:ga9bf0c703002e360545ebd943f933fb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1cd2ec3c46754e845d9083fcca78307"><td class="memItemLeft" align="right" valign="top"><a id="gaf1cd2ec3c46754e845d9083fcca78307"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, const <a class="el" href="classTransition.html">Transition</a> &amp;t)</td></tr>
<tr class="separator:gaf1cd2ec3c46754e845d9083fcca78307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1e0cf974d650010f69166d22e7d0da"><td class="memItemLeft" align="right" valign="top"><a id="ga3e1e0cf974d650010f69166d22e7d0da"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, const <a class="el" href="classValueState.html">ValueState</a> &amp;vs)</td></tr>
<tr class="separator:ga3e1e0cf974d650010f69166d22e7d0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83eaab443b166582ff8beee576b4fd51"><td class="memItemLeft" align="right" valign="top"><a id="ga83eaab443b166582ff8beee576b4fd51"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>gcd</b> (size_t a, size_t b)</td></tr>
<tr class="separator:ga83eaab443b166582ff8beee576b4fd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21cc98547ba237fc676751c60c220415"><td class="memItemLeft" align="right" valign="top"><a id="ga21cc98547ba237fc676751c60c220415"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>lcm</b> (size_t a, size_t b)</td></tr>
<tr class="separator:ga21cc98547ba237fc676751c60c220415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab750ab8b8fe56baba66c96e38398b632"><td class="memItemLeft" align="right" valign="top"><a id="gab750ab8b8fe56baba66c96e38398b632"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;o, const <a class="el" href="classWTA.html">WTA</a> &amp;a)</td></tr>
<tr class="separator:gab750ab8b8fe56baba66c96e38398b632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb95b4bb9322c3e2aba43ef1663a035e"><td class="memItemLeft" align="right" valign="top"><a id="gadb95b4bb9322c3e2aba43ef1663a035e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ComboState::ComboState</b> (const <a class="el" href="classInputSegment.html">InputSegment</a> *s, <a class="el" href="classIntervalHeap.html">IntervalHeap</a> *)</td></tr>
<tr class="separator:gadb95b4bb9322c3e2aba43ef1663a035e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffac6cd8adcfb6bbb0cd9fc601d9a2e1"><td class="memItemLeft" align="right" valign="top"><a id="gaffac6cd8adcfb6bbb0cd9fc601d9a2e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ComboState::ComboState</b> (state_t, <a class="el" href="classIntervalTree.html">IntervalTree</a> *, <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> rp=0, <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> rr=0)</td></tr>
<tr class="separator:gaffac6cd8adcfb6bbb0cd9fc601d9a2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad80378e34fdc145bd7f0dac17c306e39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gad80378e34fdc145bd7f0dac17c306e39">ComboState::ComboState</a> (const <a class="el" href="classComboState.html">ComboState</a> &amp;, <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> rp=0, <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> rr=0)</td></tr>
<tr class="separator:gad80378e34fdc145bd7f0dac17c306e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga946acbddc843e4ade0b1f47bca5b0929"><td class="memItemLeft" align="right" valign="top"><a id="ga946acbddc843e4ade0b1f47bca5b0929"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ComboState::compatible</b> (<a class="el" href="group__output.html#ga22fde970e635fcf63962743b2d5c441d">label_t</a> label) const</td></tr>
<tr class="separator:ga946acbddc843e4ade0b1f47bca5b0929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c814d1c1c9f1a90c5fc3a1a9d89395"><td class="memItemLeft" align="right" valign="top"><a id="ga66c814d1c1c9f1a90c5fc3a1a9d89395"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ComboState::operator==</b> (const <a class="el" href="classComboState.html">ComboState</a> &amp;s) const</td></tr>
<tr class="separator:ga66c814d1c1c9f1a90c5fc3a1a9d89395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga505e9ff93681bbfe5632a15708facb63"><td class="memItemLeft" align="right" valign="top"><a id="ga505e9ff93681bbfe5632a15708facb63"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga505e9ff93681bbfe5632a15708facb63">ComboState::operator&lt;</a> (const <a class="el" href="classComboState.html">ComboState</a> &amp;s) const</td></tr>
<tr class="memdesc:ga505e9ff93681bbfe5632a15708facb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">lexicographic comparison on hash value (array[5]) <br /></td></tr>
<tr class="separator:ga505e9ff93681bbfe5632a15708facb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a6c3a5867fefdac97470fd083aaa2dd"><td class="memItemLeft" align="right" valign="top">state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga2a6c3a5867fefdac97470fd083aaa2dd">ComboWTA::initial</a> (<a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> pre=0, <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> post=0) const</td></tr>
<tr class="memdesc:ga2a6c3a5867fefdac97470fd083aaa2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">state representing the whole segment.  <a href="#ga2a6c3a5867fefdac97470fd083aaa2dd">More...</a><br /></td></tr>
<tr class="separator:ga2a6c3a5867fefdac97470fd083aaa2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c589573251ec74dbe6a3c9176c39bb7"><td class="memItemLeft" align="right" valign="top"><a id="ga4c589573251ec74dbe6a3c9176c39bb7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga4c589573251ec74dbe6a3c9176c39bb7">ComboWTA::ComboWTA</a> (const <a class="el" href="classInputSegment.html">InputSegment</a> *, size_t bloc, const <a class="el" href="classWTA.html">WTA</a> &amp;, <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> pre=0)</td></tr>
<tr class="memdesc:ga4c589573251ec74dbe6a3c9176c39bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction from input segment and <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> (base schema) with given max pre value and bloc number (in input segment, for alignement). <br /></td></tr>
<tr class="separator:ga4c589573251ec74dbe6a3c9176c39bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad46a7f821d01aed3719a585f66130e27"><td class="memItemLeft" align="right" valign="top"><a id="gad46a7f821d01aed3719a585f66130e27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gad46a7f821d01aed3719a585f66130e27">CountingWTA::CountingWTA</a> ()</td></tr>
<tr class="memdesc:gad46a7f821d01aed3719a585f66130e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">default initializer for cython <br /></td></tr>
<tr class="separator:gad46a7f821d01aed3719a585f66130e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590bb9036b59d5cf81bbbedb18d19093"><td class="memItemLeft" align="right" valign="top"><a id="ga590bb9036b59d5cf81bbbedb18d19093"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga590bb9036b59d5cf81bbbedb18d19093">CountingWTA::CountingWTA</a> (const <a class="el" href="classWTA.html">WTA</a> &amp;a)</td></tr>
<tr class="memdesc:ga590bb9036b59d5cf81bbbedb18d19093"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy base <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> reset weight values to counting weights (unit vectors) <br /></td></tr>
<tr class="separator:ga590bb9036b59d5cf81bbbedb18d19093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c94f5191975a32e951e7d39ac606dc0"><td class="memItemLeft" align="right" valign="top"><a id="ga5c94f5191975a32e951e7d39ac606dc0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga5c94f5191975a32e951e7d39ac606dc0">CountingWTA::resetCounting</a> (size_t dim)</td></tr>
<tr class="memdesc:ga5c94f5191975a32e951e7d39ac606dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">the weight of this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> are replaced by "CountingWeight" unit vector of length dim (one unit per transition) <br /></td></tr>
<tr class="separator:ga5c94f5191975a32e951e7d39ac606dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2665883ffe41001dd7c2568bc9bef02f"><td class="memItemLeft" align="right" valign="top"><a id="ga2665883ffe41001dd7c2568bc9bef02f"></a>
virtual <a class="el" href="classWeight.html">Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga2665883ffe41001dd7c2568bc9bef02f">CountingWTA::eval</a> (const <a class="el" href="classRhythmTree.html">RhythmTree</a> &amp;t) const</td></tr>
<tr class="memdesc:ga2665883ffe41001dd7c2568bc9bef02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">special version of eval for <a class="el" href="classCountingWeight.html" title="domain : vectors of fixed dim k &gt; 0">CountingWeight</a> with feedback in case of fail <br /></td></tr>
<tr class="separator:ga2665883ffe41001dd7c2568bc9bef02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6ae649f73205b3390f82c3f996f6a3"><td class="memItemLeft" align="right" valign="top"><a id="ga3a6ae649f73205b3390f82c3f996f6a3"></a>
<a class="el" href="classWeight.html">Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><b>CountingWTA::evalCountingVerbose</b> (const <a class="el" href="classRhythmTree.html">RhythmTree</a> &amp;, state_t, <a class="el" href="classPosition.html">Position</a>) const</td></tr>
<tr class="separator:ga3a6ae649f73205b3390f82c3f996f6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43261a1dcc43a298836fbe62912f8a8"><td class="memItemLeft" align="right" valign="top"><a id="gae43261a1dcc43a298836fbe62912f8a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PreState::PreState</b> (state_t, <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> pre=0, <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> post=0)</td></tr>
<tr class="separator:gae43261a1dcc43a298836fbe62912f8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0c5bcc094646426f0a90313808907b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gabc0c5bcc094646426f0a90313808907b">PreState::PreState</a> (const <a class="el" href="classPreState.html">PreState</a> &amp;)</td></tr>
<tr class="separator:gabc0c5bcc094646426f0a90313808907b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b20db3eff6b527dbbc19bb92f2649d"><td class="memItemLeft" align="right" valign="top"><a id="gad8b20db3eff6b527dbbc19bb92f2649d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>PreState::operator==</b> (const <a class="el" href="classPreState.html">PreState</a> &amp;s) const</td></tr>
<tr class="separator:gad8b20db3eff6b527dbbc19bb92f2649d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa39a99008e7809c864be28f89c5ef79b"><td class="memItemLeft" align="right" valign="top"><a id="gaa39a99008e7809c864be28f89c5ef79b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaa39a99008e7809c864be28f89c5ef79b">PreState::operator&lt;</a> (const <a class="el" href="classPreState.html">PreState</a> &amp;s) const</td></tr>
<tr class="memdesc:gaa39a99008e7809c864be28f89c5ef79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">lexicographic comparison on hash value (array[5]) <br /></td></tr>
<tr class="separator:gaa39a99008e7809c864be28f89c5ef79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa60c0f6f8e237bad468bd8a48c3263f4"><td class="memItemLeft" align="right" valign="top"><a id="gaa60c0f6f8e237bad468bd8a48c3263f4"></a>
state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaa60c0f6f8e237bad468bd8a48c3263f4">PreState::serialize</a> ()</td></tr>
<tr class="memdesc:gaa60c0f6f8e237bad468bd8a48c3263f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a state value unically associated to this <a class="el" href="classPreState.html" title="tmp state structure for construction of PreWTA from a WTA (base schema) casted aka state_t after cons...">PreState</a> <br /></td></tr>
<tr class="separator:gaa60c0f6f8e237bad468bd8a48c3263f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab947b64699704a087db2eda3eb47575d"><td class="memItemLeft" align="right" valign="top"><a id="gab947b64699704a087db2eda3eb47575d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>PreState::compatible</b> (<a class="el" href="group__output.html#ga22fde970e635fcf63962743b2d5c441d">label_t</a> label) const</td></tr>
<tr class="separator:gab947b64699704a087db2eda3eb47575d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa509247277fd021460056bfe6484a5b4"><td class="memItemLeft" align="right" valign="top"><a id="gaa509247277fd021460056bfe6484a5b4"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaa509247277fd021460056bfe6484a5b4">PreState::compatible_post</a> (state_t, const <a class="el" href="classAlignedInterval.html">AlignedInterval</a> *)</td></tr>
<tr class="memdesc:gaa509247277fd021460056bfe6484a5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">compatible(s, al) the serialized state value s is compatible with the content of the alignment al (sub-segment of initial input corr. to an interval) <br /></td></tr>
<tr class="separator:gaa509247277fd021460056bfe6484a5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6287aa82de69987b65518b4997112ac5"><td class="memItemLeft" align="right" valign="top"><a id="ga6287aa82de69987b65518b4997112ac5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga6287aa82de69987b65518b4997112ac5">PreWTA::PreWTA</a> (const <a class="el" href="classWTA.html">WTA</a> &amp;)</td></tr>
<tr class="memdesc:ga6287aa82de69987b65518b4997112ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction from <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> (base schema) <br /></td></tr>
<tr class="separator:ga6287aa82de69987b65518b4997112ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab30a1faaa381ecfabd705a8c12d179b"><td class="memItemLeft" align="right" valign="top"><a id="gaab30a1faaa381ecfabd705a8c12d179b"></a>
static <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaab30a1faaa381ecfabd705a8c12d179b">PreWTA::pre</a> (state_t)</td></tr>
<tr class="memdesc:gaab30a1faaa381ecfabd705a8c12d179b"><td class="mdescLeft">&#160;</td><td class="mdescRight">access to original components of new <a class="el" href="classPreWTA.html" title="extension of WTA where states are associated pre and post values.">PreWTA</a> states <br /></td></tr>
<tr class="separator:gaab30a1faaa381ecfabd705a8c12d179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8c24b19312ad6436eaf76e4506e02f"><td class="memItemLeft" align="right" valign="top"><a id="ga2c8c24b19312ad6436eaf76e4506e02f"></a>
static <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>PreWTA::post</b> (state_t)</td></tr>
<tr class="separator:ga2c8c24b19312ad6436eaf76e4506e02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e74404d5f453b8eed85254791724ffe"><td class="memItemLeft" align="right" valign="top"><a id="ga3e74404d5f453b8eed85254791724ffe"></a>
static state_t&#160;</td><td class="memItemRight" valign="bottom"><b>PreWTA::state</b> (state_t)</td></tr>
<tr class="separator:ga3e74404d5f453b8eed85254791724ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf47213e6243f48f06681089e03fa08ef"><td class="memItemLeft" align="right" valign="top"><a id="gaf47213e6243f48f06681089e03fa08ef"></a>
virtual state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaf47213e6243f48f06681089e03fa08ef">PreWTA::initial</a> (<a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> <a class="el" href="group__schemata.html#gaab30a1faaa381ecfabd705a8c12d179b">pre</a>=0, <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> post=0) const</td></tr>
<tr class="memdesc:gaf47213e6243f48f06681089e03fa08ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">initial(pre, port) returns state representing the whole segment, with pre points of the previous segment aligned to the left and post points of the current segment aligned to the right (i.e. to the left of the next segment) <br /></td></tr>
<tr class="separator:gaf47213e6243f48f06681089e03fa08ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b5cf5f92a0c443d4c1a1e152f9292c"><td class="memItemLeft" align="right" valign="top"><a id="gaa5b5cf5f92a0c443d4c1a1e152f9292c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>State::isMeta</b> (state_t)</td></tr>
<tr class="separator:gaa5b5cf5f92a0c443d4c1a1e152f9292c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1722ba39591c8a25ed5ee91e9e91232a"><td class="memItemLeft" align="right" valign="top"><a id="ga1722ba39591c8a25ed5ee91e9e91232a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>State::isWTA</b> (state_t)</td></tr>
<tr class="separator:ga1722ba39591c8a25ed5ee91e9e91232a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd744185c22c686d1c95d74523a007b3"><td class="memItemLeft" align="right" valign="top"><a id="gabd744185c22c686d1c95d74523a007b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>State::isLabel</b> (state_t)</td></tr>
<tr class="separator:gabd744185c22c686d1c95d74523a007b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ffeaad4a7482bc302dce44a23a85a6e"><td class="memItemLeft" align="right" valign="top"><a id="ga0ffeaad4a7482bc302dce44a23a85a6e"></a>
state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga0ffeaad4a7482bc302dce44a23a85a6e">State::MetaState</a> (size_t barnb)</td></tr>
<tr class="memdesc:ga0ffeaad4a7482bc302dce44a23a85a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta state corresponding to bar nb barnb. <br /></td></tr>
<tr class="separator:ga0ffeaad4a7482bc302dce44a23a85a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99612639925cfc0a63a173ea167a6d3b"><td class="memItemLeft" align="right" valign="top"><a id="ga99612639925cfc0a63a173ea167a6d3b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ds_transition::rename</b> (unsigned int s, unsigned int u)</td></tr>
<tr class="separator:ga99612639925cfc0a63a173ea167a6d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6bf3664ce3ec4ceddc6fc0546e7af84"><td class="memItemLeft" align="right" valign="top"><a id="gaa6bf3664ce3ec4ceddc6fc0546e7af84"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaa6bf3664ce3ec4ceddc6fc0546e7af84">ds_transition::shift</a> (unsigned int n)</td></tr>
<tr class="memdesc:gaa6bf3664ce3ec4ceddc6fc0546e7af84"><td class="mdescLeft">&#160;</td><td class="mdescRight">increase source and target state by n <br /></td></tr>
<tr class="separator:gaa6bf3664ce3ec4ceddc6fc0546e7af84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga811afd94c0a2afda729115e1afade496"><td class="memItemLeft" align="right" valign="top"><a id="ga811afd94c0a2afda729115e1afade496"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga811afd94c0a2afda729115e1afade496">ds_transition::shift0</a> (unsigned int n)</td></tr>
<tr class="memdesc:ga811afd94c0a2afda729115e1afade496"><td class="mdescLeft">&#160;</td><td class="mdescRight">increase source and target state by n, if they are not 0 <br /></td></tr>
<tr class="separator:ga811afd94c0a2afda729115e1afade496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1762a1cf61c23100f58a69f092f94e27"><td class="memItemLeft" align="right" valign="top"><a id="ga1762a1cf61c23100f58a69f092f94e27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga1762a1cf61c23100f58a69f092f94e27">dagSchema::dagSchema</a> (const <a class="el" href="classANode.html">ANode</a> &amp;)</td></tr>
<tr class="memdesc:ga1762a1cf61c23100f58a69f092f94e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">translation of AND-OR alternating nested lists into dag-schemas <br /></td></tr>
<tr class="separator:ga1762a1cf61c23100f58a69f092f94e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1258e692e42b123b039e9aa1c256b8"><td class="memItemLeft" align="right" valign="top"><a id="ga7f1258e692e42b123b039e9aa1c256b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dagSchema::dagSchema</b> (const <a class="el" href="classONode.html">ONode</a> &amp;)</td></tr>
<tr class="separator:ga7f1258e692e42b123b039e9aa1c256b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc3e9cf7edbc289976639574ca23d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga0dc3e9cf7edbc289976639574ca23d20">dagSchema::add</a> (const <a class="el" href="structds__transition.html">ds_transition</a> &amp;dst)</td></tr>
<tr class="separator:ga0dc3e9cf7edbc289976639574ca23d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b44b2338b11807f77b620a3e810f92"><td class="memItemLeft" align="right" valign="top"><a id="ga73b44b2338b11807f77b620a3e810f92"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga73b44b2338b11807f77b620a3e810f92">Transition::Transition</a> ()</td></tr>
<tr class="memdesc:ga73b44b2338b11807f77b620a3e810f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">transition with unknown weight and empty body. <br /></td></tr>
<tr class="separator:ga73b44b2338b11807f77b620a3e810f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e08e637325ab62ee6bfbdb99c8f8a71"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga6e08e637325ab62ee6bfbdb99c8f8a71">Transition::Transition</a> (const <a class="el" href="classWeight.html">Weight</a> &amp;)</td></tr>
<tr class="memdesc:ga6e08e637325ab62ee6bfbdb99c8f8a71"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTransition.html" title="a Transition is defined by a sequence of antecedent states (body) the weight must be not null (null w...">Transition(w)</a> creates a transition with weight a copy of w and empty body.  <a href="#ga6e08e637325ab62ee6bfbdb99c8f8a71">More...</a><br /></td></tr>
<tr class="separator:ga6e08e637325ab62ee6bfbdb99c8f8a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09dca130387fcf6ead3f80cc523a59de"><td class="memItemLeft" align="right" valign="top"><a id="ga09dca130387fcf6ead3f80cc523a59de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga09dca130387fcf6ead3f80cc523a59de">Transition::Transition</a> (<a class="el" href="classLetterWeight.html">LetterWeight</a> *)</td></tr>
<tr class="memdesc:ga09dca130387fcf6ead3f80cc523a59de"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTransition.html" title="a Transition is defined by a sequence of antecedent states (body) the weight must be not null (null w...">Transition(lw)</a> creates a transition with weight a wrapper of the letter lw (must be non null) <br /></td></tr>
<tr class="separator:ga09dca130387fcf6ead3f80cc523a59de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad126f7c68acac0315b1782decaf54d3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gad126f7c68acac0315b1782decaf54d3b">Transition::Transition</a> (std::vector&lt; state_t &gt;, const <a class="el" href="classWeight.html">Weight</a> &amp;)</td></tr>
<tr class="memdesc:gad126f7c68acac0315b1782decaf54d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTransition.html" title="a Transition is defined by a sequence of antecedent states (body) the weight must be not null (null w...">Transition(v, w)</a> creates a transition with weight a copy of w and body a copy of the vector v.  <a href="#gad126f7c68acac0315b1782decaf54d3b">More...</a><br /></td></tr>
<tr class="separator:gad126f7c68acac0315b1782decaf54d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50836c0d84b3968b9ceb968521418e22"><td class="memItemLeft" align="right" valign="top"><a id="ga50836c0d84b3968b9ceb968521418e22"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga50836c0d84b3968b9ceb968521418e22">Transition::Transition</a> (std::vector&lt; state_t &gt;, <a class="el" href="classLetterWeight.html">LetterWeight</a> *)</td></tr>
<tr class="memdesc:ga50836c0d84b3968b9ceb968521418e22"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTransition.html" title="a Transition is defined by a sequence of antecedent states (body) the weight must be not null (null w...">Transition(v, lw)</a> creates a transition with weight a wrapper of the letter lw (must be non null) and body a copy of the vector v. <br /></td></tr>
<tr class="separator:ga50836c0d84b3968b9ceb968521418e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c71fb93c73a755408cc963975d4ffa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga3c71fb93c73a755408cc963975d4ffa5">Transition::Transition</a> (state_t, const <a class="el" href="classWeight.html">Weight</a> &amp;)</td></tr>
<tr class="memdesc:ga3c71fb93c73a755408cc963975d4ffa5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTransition.html" title="a Transition is defined by a sequence of antecedent states (body) the weight must be not null (null w...">Transition(s, w)</a> creates a transition with weight a copy of w and body (of size 1) the singleton (s) (terminal symbol).  <a href="#ga3c71fb93c73a755408cc963975d4ffa5">More...</a><br /></td></tr>
<tr class="separator:ga3c71fb93c73a755408cc963975d4ffa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458b953211e3b5de292c8c1535ff7281"><td class="memItemLeft" align="right" valign="top"><a id="ga458b953211e3b5de292c8c1535ff7281"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga458b953211e3b5de292c8c1535ff7281">Transition::Transition</a> (state_t, <a class="el" href="classLetterWeight.html">LetterWeight</a> *)</td></tr>
<tr class="memdesc:ga458b953211e3b5de292c8c1535ff7281"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classTransition.html" title="a Transition is defined by a sequence of antecedent states (body) the weight must be not null (null w...">Transition(s, lw)</a> creates a transition with weight a wrapper of the letter lw (must be non null) and body (of size 1) the singleton (s) (terminal symbol). <br /></td></tr>
<tr class="separator:ga458b953211e3b5de292c8c1535ff7281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb18d5879ecb7757b5e783866c3e6084"><td class="memItemLeft" align="right" valign="top"><a id="gaeb18d5879ecb7757b5e783866c3e6084"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Transition::inner</b> () const</td></tr>
<tr class="separator:gaeb18d5879ecb7757b5e783866c3e6084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1191490a05cc7d04a9933e5d84ca9fcd"><td class="memItemLeft" align="right" valign="top"><a id="ga1191490a05cc7d04a9933e5d84ca9fcd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Transition::terminal</b> () const</td></tr>
<tr class="separator:ga1191490a05cc7d04a9933e5d84ca9fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97dce48d13fac75a4a444a68aae07608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__output.html#ga22fde970e635fcf63962743b2d5c441d">label_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga97dce48d13fac75a4a444a68aae07608">Transition::label</a> () const</td></tr>
<tr class="separator:ga97dce48d13fac75a4a444a68aae07608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7e864cf11645e39e3999516c2438f7"><td class="memItemLeft" align="right" valign="top"><a id="ga6d7e864cf11645e39e3999516c2438f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga6d7e864cf11645e39e3999516c2438f7">Transition::scalar</a> (double)</td></tr>
<tr class="memdesc:ga6d7e864cf11645e39e3999516c2438f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">modify weight of transition. <br /></td></tr>
<tr class="separator:ga6d7e864cf11645e39e3999516c2438f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00585e8726be305c0a0d5b9af9c585b0"><td class="memItemLeft" align="right" valign="top"><a id="ga00585e8726be305c0a0d5b9af9c585b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Transition::invert</b> ()</td></tr>
<tr class="separator:ga00585e8726be305c0a0d5b9af9c585b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga743ca128dc509e129a49d66500a0f151"><td class="memItemLeft" align="right" valign="top"><a id="ga743ca128dc509e129a49d66500a0f151"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga743ca128dc509e129a49d66500a0f151">Transition::size</a> () const</td></tr>
<tr class="memdesc:ga743ca128dc509e129a49d66500a0f151"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of body. <br /></td></tr>
<tr class="separator:ga743ca128dc509e129a49d66500a0f151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ae5de36df4526b83bf7af59d178066"><td class="memItemLeft" align="right" valign="top"><a id="gad6ae5de36df4526b83bf7af59d178066"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>Transition::arity</b> () const</td></tr>
<tr class="separator:gad6ae5de36df4526b83bf7af59d178066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e2e243bfa147bafd947f2cffd1da3ec"><td class="memItemLeft" align="right" valign="top">state_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga9e2e243bfa147bafd947f2cffd1da3ec">Transition::at</a> (size_t i) const</td></tr>
<tr class="memdesc:ga9e2e243bfa147bafd947f2cffd1da3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">at(i) returns the ith state in the body.  <a href="#ga9e2e243bfa147bafd947f2cffd1da3ec">More...</a><br /></td></tr>
<tr class="separator:ga9e2e243bfa147bafd947f2cffd1da3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc3c061a48c15ce02b2ead05f9bb2bf"><td class="memItemLeft" align="right" valign="top"><a id="gaacc3c061a48c15ce02b2ead05f9bb2bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaacc3c061a48c15ce02b2ead05f9bb2bf">Transition::push</a> (state_t)</td></tr>
<tr class="memdesc:gaacc3c061a48c15ce02b2ead05f9bb2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">add given state at the end of the body of this transition. <br /></td></tr>
<tr class="separator:gaacc3c061a48c15ce02b2ead05f9bb2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab94ff39ee66515e72c1c52ba855508c8"><td class="memItemLeft" align="right" valign="top"><a id="gab94ff39ee66515e72c1c52ba855508c8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gab94ff39ee66515e72c1c52ba855508c8">Transition::member</a> (state_t) const</td></tr>
<tr class="memdesc:gab94ff39ee66515e72c1c52ba855508c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the given state belongs to the body of this transition. <br /></td></tr>
<tr class="separator:gab94ff39ee66515e72c1c52ba855508c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9719bf4a7c1e1ec8e0e1fceed8da0a11"><td class="memItemLeft" align="right" valign="top"><a id="ga9719bf4a7c1e1ec8e0e1fceed8da0a11"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga9719bf4a7c1e1ec8e0e1fceed8da0a11">Transition::allin</a> (const std::set&lt; state_t &gt; &amp;) const</td></tr>
<tr class="memdesc:ga9719bf4a7c1e1ec8e0e1fceed8da0a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">every state of the body is in the given set. <br /></td></tr>
<tr class="separator:ga9719bf4a7c1e1ec8e0e1fceed8da0a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bb49bac8dc5d5dbfb955b9eaea29276"><td class="memItemLeft" align="right" valign="top"><a id="ga6bb49bac8dc5d5dbfb955b9eaea29276"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga6bb49bac8dc5d5dbfb955b9eaea29276">Transition::nonein</a> (const std::set&lt; state_t &gt; &amp;) const</td></tr>
<tr class="memdesc:ga6bb49bac8dc5d5dbfb955b9eaea29276"><td class="mdescLeft">&#160;</td><td class="mdescRight">no state of the body is in the given set. <br /></td></tr>
<tr class="separator:ga6bb49bac8dc5d5dbfb955b9eaea29276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78ce9830cde7d7875888ab5b420beecf"><td class="memItemLeft" align="right" valign="top"><a id="ga78ce9830cde7d7875888ab5b420beecf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ValueState::ValueState</b> (state_t, <a class="el" href="classDurationTree.html">DurationTree</a> *)</td></tr>
<tr class="separator:ga78ce9830cde7d7875888ab5b420beecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64b0072478e5475befdb4b0212d8e2e"><td class="memItemLeft" align="right" valign="top"><a id="gaa64b0072478e5475befdb4b0212d8e2e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ValueState::compatible</b> (<a class="el" href="group__output.html#ga22fde970e635fcf63962743b2d5c441d">label_t</a> label) const</td></tr>
<tr class="separator:gaa64b0072478e5475befdb4b0212d8e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e4a967143877229169d6c28842185c8"><td class="memItemLeft" align="right" valign="top"><a id="ga8e4a967143877229169d6c28842185c8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ValueState::operator==</b> (const <a class="el" href="classValueState.html">ValueState</a> &amp;s) const</td></tr>
<tr class="separator:ga8e4a967143877229169d6c28842185c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35a1ee1d6e2b2b5d82b930b4d70340f"><td class="memItemLeft" align="right" valign="top"><a id="gab35a1ee1d6e2b2b5d82b930b4d70340f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gab35a1ee1d6e2b2b5d82b930b4d70340f">ValueWTA::ValueWTA</a> (const <a class="el" href="classDurationList.html">DurationList</a> &amp;, const <a class="el" href="classWTA.html">WTA</a> &amp;)</td></tr>
<tr class="memdesc:gab35a1ee1d6e2b2b5d82b930b4d70340f"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction from given initial list and <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> (base schema) <br /></td></tr>
<tr class="separator:gab35a1ee1d6e2b2b5d82b930b4d70340f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba83dbc74a223a80ad7f8776847bd6c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaba83dbc74a223a80ad7f8776847bd6c2">TransitionList::empty</a> () const</td></tr>
<tr class="memdesc:gaba83dbc74a223a80ad7f8776847bd6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">zero transition  <a href="#gaba83dbc74a223a80ad7f8776847bd6c2">More...</a><br /></td></tr>
<tr class="separator:gaba83dbc74a223a80ad7f8776847bd6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa719dbdab17047360e889910795a07f2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaa719dbdab17047360e889910795a07f2">TransitionList::size</a> () const</td></tr>
<tr class="memdesc:gaa719dbdab17047360e889910795a07f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of transitions.  <a href="#gaa719dbdab17047360e889910795a07f2">More...</a><br /></td></tr>
<tr class="separator:gaa719dbdab17047360e889910795a07f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc77b77a90197483168626230fe4dbf4"><td class="memItemLeft" align="right" valign="top"><a id="gadc77b77a90197483168626230fe4dbf4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TransitionList::add</b> (const <a class="el" href="classTransition.html">Transition</a> &amp;)</td></tr>
<tr class="separator:gadc77b77a90197483168626230fe4dbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f4181b350f6dec7054072fcf2095834"><td class="memItemLeft" align="right" valign="top"><a id="ga2f4181b350f6dec7054072fcf2095834"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TransitionList::clear</b> ()</td></tr>
<tr class="separator:ga2f4181b350f6dec7054072fcf2095834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9709d189b3748d2285f2a3592bed2da"><td class="memItemLeft" align="right" valign="top"><a id="gad9709d189b3748d2285f2a3592bed2da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TransitionList::remove</b> (TransitionList_iterator)</td></tr>
<tr class="separator:gad9709d189b3748d2285f2a3592bed2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c5b906f3ce72168effc16b06ed1ef6c"><td class="memItemLeft" align="right" valign="top"><a id="ga3c5b906f3ce72168effc16b06ed1ef6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga3c5b906f3ce72168effc16b06ed1ef6c">TransitionList::remove</a> (state_t)</td></tr>
<tr class="memdesc:ga3c5b906f3ce72168effc16b06ed1ef6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all transitions of length &gt; 1 in the list containing the given state do not remove length 1 transitions to terminal symbols <br /></td></tr>
<tr class="separator:ga3c5b906f3ce72168effc16b06ed1ef6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5636da911ebbe8772c5444172d56800d"><td class="memItemLeft" align="right" valign="top"><a id="ga5636da911ebbe8772c5444172d56800d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga5636da911ebbe8772c5444172d56800d">WTA::WTA</a> ()</td></tr>
<tr class="memdesc:ga5636da911ebbe8772c5444172d56800d"><td class="mdescLeft">&#160;</td><td class="mdescRight">nullary constructor for cython <br /></td></tr>
<tr class="separator:ga5636da911ebbe8772c5444172d56800d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eeb789b8c8aa8404f611a6fed61faca"><td class="memItemLeft" align="right" valign="top"><a id="ga6eeb789b8c8aa8404f611a6fed61faca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga6eeb789b8c8aa8404f611a6fed61faca">WTA::WTA</a> (<a class="el" href="classWeight.html">Weight</a> seed, <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> pre=0, <a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a> post=0)</td></tr>
<tr class="memdesc:ga6eeb789b8c8aa8404f611a6fed61faca"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty automaton <br /></td></tr>
<tr class="separator:ga6eeb789b8c8aa8404f611a6fed61faca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab201fee50d73843159cbef5f453838f0"><td class="memItemLeft" align="right" valign="top"><a id="gab201fee50d73843159cbef5f453838f0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gab201fee50d73843159cbef5f453838f0">WTA::size</a> () const</td></tr>
<tr class="memdesc:gab201fee50d73843159cbef5f453838f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of states <br /></td></tr>
<tr class="separator:gab201fee50d73843159cbef5f453838f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada977ff7270308f29852b59f38965bde"><td class="memItemLeft" align="right" valign="top"><a id="gada977ff7270308f29852b59f38965bde"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>WTA::empty</b> () const</td></tr>
<tr class="separator:gada977ff7270308f29852b59f38965bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4459bd6654cbe35b39df9cade16c6d58"><td class="memItemLeft" align="right" valign="top"><a id="ga4459bd6654cbe35b39df9cade16c6d58"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga4459bd6654cbe35b39df9cade16c6d58">WTA::isRegistered</a> (state_t) const</td></tr>
<tr class="memdesc:ga4459bd6654cbe35b39df9cade16c6d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">the state is present in the automaton <br /></td></tr>
<tr class="separator:ga4459bd6654cbe35b39df9cade16c6d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d07a1e47cc3ee537234861b7336dd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga88d07a1e47cc3ee537234861b7336dd6">WTA::isInitial</a> (state_t) const</td></tr>
<tr class="memdesc:ga88d07a1e47cc3ee537234861b7336dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the state is an initial state  <a href="#ga88d07a1e47cc3ee537234861b7336dd6">More...</a><br /></td></tr>
<tr class="separator:ga88d07a1e47cc3ee537234861b7336dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924a1c533383a7185b9d466b59c5a495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransitionList.html">TransitionList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga924a1c533383a7185b9d466b59c5a495">WTA::add</a> (state_t, bool <a class="el" href="classWTA.html#ae6b10f70925f14f36b839e5d8657bc5e">initial</a>=false)</td></tr>
<tr class="memdesc:ga924a1c533383a7185b9d466b59c5a495"><td class="mdescLeft">&#160;</td><td class="mdescRight">add(s, i) register state s if s was already registered, return a reference to its transition list. otherwise, create state s with an empty transition list and returns a reference to it. moreover s is set as initial if i = true.  <a href="#ga924a1c533383a7185b9d466b59c5a495">More...</a><br /></td></tr>
<tr class="separator:ga924a1c533383a7185b9d466b59c5a495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01de1e03d09518b38ab69a2075276ae2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTransitionList.html">TransitionList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga01de1e03d09518b38ab69a2075276ae2">WTA::add</a> (state_t, const <a class="el" href="classTransition.html">Transition</a> &amp;, bool <a class="el" href="classWTA.html#ae6b10f70925f14f36b839e5d8657bc5e">initial</a>=false)</td></tr>
<tr class="memdesc:ga01de1e03d09518b38ab69a2075276ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">add(s, t) add a transition with head s and with body/weight described in t if s was not registered, it is registered the transition t is added to the transition list of s and a reference to this transition list is returned moreover s is set as initial if i = true.  <a href="#ga01de1e03d09518b38ab69a2075276ae2">More...</a><br /></td></tr>
<tr class="separator:ga01de1e03d09518b38ab69a2075276ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d8d24249e26ecc8bbdaf672c6e8d3cf"><td class="memItemLeft" align="right" valign="top"><a id="ga3d8d24249e26ecc8bbdaf672c6e8d3cf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga3d8d24249e26ecc8bbdaf672c6e8d3cf">WTA::remove</a> (state_t)</td></tr>
<tr class="memdesc:ga3d8d24249e26ecc8bbdaf672c6e8d3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the entry for given state s in the table of the table i.e. all transitions targeted to s, and all the transitions with s in their body. if s was in the initial set, it is also removed from this set. s must be registered. <br /></td></tr>
<tr class="separator:ga3d8d24249e26ecc8bbdaf672c6e8d3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23c3f9884c683e4bbab323208e08c672"><td class="memItemLeft" align="right" valign="top"><a id="ga23c3f9884c683e4bbab323208e08c672"></a>
TransitionList_const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga23c3f9884c683e4bbab323208e08c672">WTA::begin</a> (state_t) const</td></tr>
<tr class="memdesc:ga23c3f9884c683e4bbab323208e08c672"><td class="mdescLeft">&#160;</td><td class="mdescRight">begin(s) returns an iterator pointing to the first transition with head state s. s must be registered. not for modifying transition list of s. use add(...) methods for this. <br /></td></tr>
<tr class="separator:ga23c3f9884c683e4bbab323208e08c672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5075f5a210343d6da208f4c80421cb5"><td class="memItemLeft" align="right" valign="top"><a id="gaf5075f5a210343d6da208f4c80421cb5"></a>
TransitionList_const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaf5075f5a210343d6da208f4c80421cb5">WTA::end</a> (state_t) const</td></tr>
<tr class="memdesc:gaf5075f5a210343d6da208f4c80421cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">begin(s) returns an iterator pointing to the past-the-end transition with head state s. s must be registered. not for modifying transition list of s. use add(...) methods for this. <br /></td></tr>
<tr class="separator:gaf5075f5a210343d6da208f4c80421cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f6551b20a213eb88c6a7e822ebc5915"><td class="memItemLeft" align="right" valign="top"><a id="ga0f6551b20a213eb88c6a7e822ebc5915"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga0f6551b20a213eb88c6a7e822ebc5915">WTA::countStates</a> () const</td></tr>
<tr class="memdesc:ga0f6551b20a213eb88c6a7e822ebc5915"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of states <br /></td></tr>
<tr class="separator:ga0f6551b20a213eb88c6a7e822ebc5915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8acbd7562a6f69e7634d6b9f9e341e4a"><td class="memItemLeft" align="right" valign="top"><a id="ga8acbd7562a6f69e7634d6b9f9e341e4a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga8acbd7562a6f69e7634d6b9f9e341e4a">WTA::countTransitions</a> () const</td></tr>
<tr class="memdesc:ga8acbd7562a6f69e7634d6b9f9e341e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of transition <br /></td></tr>
<tr class="separator:ga8acbd7562a6f69e7634d6b9f9e341e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9370cdd31619d49bfb0b18fa6b4e13b7"><td class="memItemLeft" align="right" valign="top"><a id="ga9370cdd31619d49bfb0b18fa6b4e13b7"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga9370cdd31619d49bfb0b18fa6b4e13b7">WTA::countAll</a> () const</td></tr>
<tr class="memdesc:ga9370cdd31619d49bfb0b18fa6b4e13b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of symbols (state occurences) <br /></td></tr>
<tr class="separator:ga9370cdd31619d49bfb0b18fa6b4e13b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28c9a7e35d4d516ef0f9967e773305f8"><td class="memItemLeft" align="right" valign="top"><a id="ga28c9a7e35d4d516ef0f9967e773305f8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga28c9a7e35d4d516ef0f9967e773305f8">WTA::oftarget</a> (state_t) const</td></tr>
<tr class="memdesc:ga28c9a7e35d4d516ef0f9967e773305f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">oftarget(s) return the number of transitions of head state s. s must be registered. <br /></td></tr>
<tr class="separator:ga28c9a7e35d4d516ef0f9967e773305f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga625d9da502c5cd554797ebe9ee9023c4"><td class="memItemLeft" align="right" valign="top"><a id="ga625d9da502c5cd554797ebe9ee9023c4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>WTA::resolution</b> () const</td></tr>
<tr class="separator:ga625d9da502c5cd554797ebe9ee9023c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6fb2dbd82ed290528b90ee7bb4b6ccc"><td class="memItemLeft" align="right" valign="top"><a id="gae6fb2dbd82ed290528b90ee7bb4b6ccc"></a>
std::set&lt; state_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gae6fb2dbd82ed290528b90ee7bb4b6ccc">WTA::step</a> (const std::set&lt; state_t &gt; &amp;)</td></tr>
<tr class="memdesc:gae6fb2dbd82ed290528b90ee7bb4b6ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">step(s) returns the set of states reachable in one transition step by this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> from the given state set s. all the states in the set s must be registered. <br /></td></tr>
<tr class="separator:gae6fb2dbd82ed290528b90ee7bb4b6ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8ea841b4a1e71ef70d3fda927f0507d"><td class="memItemLeft" align="right" valign="top"><a id="gab8ea841b4a1e71ef70d3fda927f0507d"></a>
std::set&lt; state_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gab8ea841b4a1e71ef70d3fda927f0507d">WTA::allStates</a> () const</td></tr>
<tr class="memdesc:gab8ea841b4a1e71ef70d3fda927f0507d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the set of all states occuring in wta (in head or body) <br /></td></tr>
<tr class="separator:gab8ea841b4a1e71ef70d3fda927f0507d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea41b32c37bbe955d0359039d7731fea"><td class="memItemLeft" align="right" valign="top"><a id="gaea41b32c37bbe955d0359039d7731fea"></a>
std::set&lt; state_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaea41b32c37bbe955d0359039d7731fea">WTA::emptyStates</a> () const</td></tr>
<tr class="memdesc:gaea41b32c37bbe955d0359039d7731fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the set of all non-inhabited (zero weight) states in wta <br /></td></tr>
<tr class="separator:gaea41b32c37bbe955d0359039d7731fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef4193ae949ae7c9e52d30720e37202"><td class="memItemLeft" align="right" valign="top"><a id="ga9ef4193ae949ae7c9e52d30720e37202"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga9ef4193ae949ae7c9e52d30720e37202">WTA::isClean</a> () const</td></tr>
<tr class="memdesc:ga9ef4193ae949ae7c9e52d30720e37202"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> has no empty states <br /></td></tr>
<tr class="separator:ga9ef4193ae949ae7c9e52d30720e37202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec169477bdc2cf883916c38dbc18e577"><td class="memItemLeft" align="right" valign="top"><a id="gaec169477bdc2cf883916c38dbc18e577"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaec169477bdc2cf883916c38dbc18e577">WTA::clean</a> ()</td></tr>
<tr class="memdesc:gaec169477bdc2cf883916c38dbc18e577"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove states not inhabited and transitions containing these states <br /></td></tr>
<tr class="separator:gaec169477bdc2cf883916c38dbc18e577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91e272f4f9463149cd296f48e65a4185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga91e272f4f9463149cd296f48e65a4185">WTA::abstract</a> (bool flag=false)</td></tr>
<tr class="memdesc:ga91e272f4f9463149cd296f48e65a4185"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract the leaf label values in domain [0..MAX_GRACE] every value &gt; MAX_GRACE is casted to MAX_GRACE the weights are summed accordingly  <a href="#ga91e272f4f9463149cd296f48e65a4185">More...</a><br /></td></tr>
<tr class="separator:ga91e272f4f9463149cd296f48e65a4185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dfef6b591f952f0fea9dae1f5e475c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga8dfef6b591f952f0fea9dae1f5e475c7">WTA::CountingtoStochastic</a> ()</td></tr>
<tr class="memdesc:ga8dfef6b591f952f0fea9dae1f5e475c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast weights in all transitions.  <a href="#ga8dfef6b591f952f0fea9dae1f5e475c7">More...</a><br /></td></tr>
<tr class="separator:ga8dfef6b591f952f0fea9dae1f5e475c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3a0d868bf26b504cccc53b4d55e09a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga5f3a0d868bf26b504cccc53b4d55e09a">WTA::CountingtoPenalty</a> ()</td></tr>
<tr class="memdesc:ga5f3a0d868bf26b504cccc53b4d55e09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast weights in all transitions.  <a href="#ga5f3a0d868bf26b504cccc53b4d55e09a">More...</a><br /></td></tr>
<tr class="separator:ga5f3a0d868bf26b504cccc53b4d55e09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff1196a45ffd1400bc4004e27b167218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaff1196a45ffd1400bc4004e27b167218">WTA::PenaltytoCounting</a> ()</td></tr>
<tr class="memdesc:gaff1196a45ffd1400bc4004e27b167218"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast weights in all transitions.  <a href="#gaff1196a45ffd1400bc4004e27b167218">More...</a><br /></td></tr>
<tr class="separator:gaff1196a45ffd1400bc4004e27b167218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bddc6750b18023be6976bd5cd46a2f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga0bddc6750b18023be6976bd5cd46a2f5">WTA::StochastictoPenalty</a> ()</td></tr>
<tr class="memdesc:ga0bddc6750b18023be6976bd5cd46a2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast weights in all transitions.  <a href="#ga0bddc6750b18023be6976bd5cd46a2f5">More...</a><br /></td></tr>
<tr class="separator:ga0bddc6750b18023be6976bd5cd46a2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c11e99698a2cf7ef039632dc5e2b6b"><td class="memItemLeft" align="right" valign="top"><a id="gaf3c11e99698a2cf7ef039632dc5e2b6b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaf3c11e99698a2cf7ef039632dc5e2b6b">WTA::hasWeightType</a> (std::string code) const</td></tr>
<tr class="memdesc:gaf3c11e99698a2cf7ef039632dc5e2b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return wether the weights in transition have the type of the code (code of the letter weight if there is one or "UNKNOWN" otherwise). <br /></td></tr>
<tr class="separator:gaf3c11e99698a2cf7ef039632dc5e2b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762b5bbee46468815993417ca9b3d9c6"><td class="memItemLeft" align="right" valign="top"><a id="ga762b5bbee46468815993417ca9b3d9c6"></a>
virtual <a class="el" href="classWeight.html">Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga762b5bbee46468815993417ca9b3d9c6">WTA::weight_zero</a> () const</td></tr>
<tr class="memdesc:ga762b5bbee46468815993417ca9b3d9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the 0 value in the weight domain in this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> <br /></td></tr>
<tr class="separator:ga762b5bbee46468815993417ca9b3d9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfe48e6398d83c03161b664dadcf8fcd"><td class="memItemLeft" align="right" valign="top"><a id="gabfe48e6398d83c03161b664dadcf8fcd"></a>
virtual <a class="el" href="classWeight.html">Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gabfe48e6398d83c03161b664dadcf8fcd">WTA::weight_one</a> () const</td></tr>
<tr class="memdesc:gabfe48e6398d83c03161b664dadcf8fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the 1 value in the weight domain in this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> <br /></td></tr>
<tr class="separator:gabfe48e6398d83c03161b664dadcf8fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6598176fb91c70988bea7cf824ec157"><td class="memItemLeft" align="right" valign="top"><a id="gaa6598176fb91c70988bea7cf824ec157"></a>
virtual <a class="el" href="classWeight.html">Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaa6598176fb91c70988bea7cf824ec157">WTA::eval</a> (const <a class="el" href="classRhythmTree.html">RhythmTree</a> &amp;t) const</td></tr>
<tr class="memdesc:gaa6598176fb91c70988bea7cf824ec157"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate the weight of the tree t for <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> in initial state <br /></td></tr>
<tr class="separator:gaa6598176fb91c70988bea7cf824ec157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac842f196f85e3c3b079c7c0992173e46"><td class="memItemLeft" align="right" valign="top"><a id="gac842f196f85e3c3b079c7c0992173e46"></a>
virtual <a class="el" href="classWeight.html">Weight</a>&#160;</td><td class="memItemRight" valign="bottom"><b>WTA::eval</b> (const <a class="el" href="classRhythmTree.html">RhythmTree</a> &amp;t, state_t s) const</td></tr>
<tr class="separator:gac842f196f85e3c3b079c7c0992173e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb713b8807bc81c6c6519ced5d531e06"><td class="memItemLeft" align="right" valign="top"><a id="gaeb713b8807bc81c6c6519ced5d531e06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaeb713b8807bc81c6c6519ced5d531e06">WTA::print</a> (std::ostream &amp;) const</td></tr>
<tr class="memdesc:gaeb713b8807bc81c6c6519ced5d531e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">print sizes to output stream <br /></td></tr>
<tr class="separator:gaeb713b8807bc81c6c6519ced5d531e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a0a9f458a39032b2c653a99f609935"><td class="memItemLeft" align="right" valign="top"><a id="gaf0a0a9f458a39032b2c653a99f609935"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DepthMarking::DepthMarking</b> (const <a class="el" href="classWTA.html">WTA</a> &amp;)</td></tr>
<tr class="separator:gaf0a0a9f458a39032b2c653a99f609935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa84e1d149651938af82e47b91888017"><td class="memItemLeft" align="right" valign="top"><a id="gaaa84e1d149651938af82e47b91888017"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gaaa84e1d149651938af82e47b91888017">DepthMarking::depth</a> (state_t) const</td></tr>
<tr class="memdesc:gaaa84e1d149651938af82e47b91888017"><td class="mdescLeft">&#160;</td><td class="mdescRight">return depth mark if given state marked return -1 otherwise <br /></td></tr>
<tr class="separator:gaaa84e1d149651938af82e47b91888017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f3fa885bb5d2be624a26e9aa50dd0b"><td class="memItemLeft" align="right" valign="top"><a id="gad5f3fa885bb5d2be624a26e9aa50dd0b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#gad5f3fa885bb5d2be624a26e9aa50dd0b">DepthMarking::multiple</a> (state_t) const</td></tr>
<tr class="memdesc:gad5f3fa885bb5d2be624a26e9aa50dd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if the given state can occur at multiple depths return false otherwise or if state not marked <br /></td></tr>
<tr class="separator:gad5f3fa885bb5d2be624a26e9aa50dd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3486fcb9921f3c018b931e088a53df7d"><td class="memItemLeft" align="right" valign="top"><a id="ga3486fcb9921f3c018b931e088a53df7d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga3486fcb9921f3c018b931e088a53df7d">DepthMarking::mark</a> (state_t, int)</td></tr>
<tr class="memdesc:ga3486fcb9921f3c018b931e088a53df7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">mark state using given depth and return new mark value can be the given depth or a greater depth with which the state had been already marked. <br /></td></tr>
<tr class="separator:ga3486fcb9921f3c018b931e088a53df7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga170bee814ca8089ab27a574b1f47281c"><td class="memItemLeft" align="right" valign="top"><a id="ga170bee814ca8089ab27a574b1f47281c"></a>
static bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__schemata.html#ga170bee814ca8089ab27a574b1f47281c">CountingWTA::_trcomp_ptr</a> )(std::pair&lt; state_t, <a class="el" href="classTransition.html">Transition</a> &amp;&gt;, std::pair&lt; state_t, <a class="el" href="classTransition.html">Transition</a> &amp;&gt;) = &amp;trcomp</td></tr>
<tr class="memdesc:ga170bee814ca8089ab27a574b1f47281c"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to comparison function <br /></td></tr>
<tr class="separator:ga170bee814ca8089ab27a574b1f47281c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <code>schemata</code> module contains classes of weighted tree automata used for parsing. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad80378e34fdc145bd7f0dac17c306e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad80378e34fdc145bd7f0dac17c306e39">&#9670;&nbsp;</a></span>ComboState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ComboState::ComboState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classComboState.html">ComboState</a> &amp;&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a>&#160;</td>
          <td class="paramname"><em>rp</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a>&#160;</td>
          <td class="paramname"><em>rr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>TBR </dd></dl>

</div>
</div>
<a id="ga2a6c3a5867fefdac97470fd083aaa2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a6c3a5867fefdac97470fd083aaa2dd">&#9670;&nbsp;</a></span>initial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">state_t ComboWTA::initial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a>&#160;</td>
          <td class="paramname"><em>pre</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__general.html#ga092fe8b972dfa977c2a0886720a7731e">pre_t</a>&#160;</td>
          <td class="paramname"><em>post</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>state representing the whole segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pre</td><td>points of the previous segment aligned to the left </td></tr>
    <tr><td class="paramname">post</td><td>points of the current segment aligned to the right (i.e. to the left of the next segment). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classWTA.html#ae6b10f70925f14f36b839e5d8657bc5e">WTA</a>.</p>

</div>
</div>
<a id="gabc0c5bcc094646426f0a90313808907b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc0c5bcc094646426f0a90313808907b">&#9670;&nbsp;</a></span>PreState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PreState::PreState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPreState.html">PreState</a> &amp;&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>TBR </dd></dl>

</div>
</div>
<a id="ga0dc3e9cf7edbc289976639574ca23d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dc3e9cf7edbc289976639574ca23d20">&#9670;&nbsp;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dagSchema::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structds__transition.html">ds_transition</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>for testing. do not use </dd></dl>

</div>
</div>
<a id="ga6e08e637325ab62ee6bfbdb99c8f8a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e08e637325ab62ee6bfbdb99c8f8a71">&#9670;&nbsp;</a></span>Transition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Transition::Transition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classWeight.html">Weight</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classTransition.html" title="a Transition is defined by a sequence of antecedent states (body) the weight must be not null (null w...">Transition(w)</a> creates a transition with weight a copy of w and empty body. </p>
<dl class="section warning"><dt>Warning</dt><dd>the letter weight in the envelop w is cloned </dd></dl>

</div>
</div>
<a id="gad126f7c68acac0315b1782decaf54d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad126f7c68acac0315b1782decaf54d3b">&#9670;&nbsp;</a></span>Transition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Transition::Transition </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; state_t &gt;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWeight.html">Weight</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classTransition.html" title="a Transition is defined by a sequence of antecedent states (body) the weight must be not null (null w...">Transition(v, w)</a> creates a transition with weight a copy of w and body a copy of the vector v. </p>
<dl class="section warning"><dt>Warning</dt><dd>the letter weight in the envelop w is cloned. </dd></dl>

</div>
</div>
<a id="ga3c71fb93c73a755408cc963975d4ffa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c71fb93c73a755408cc963975d4ffa5">&#9670;&nbsp;</a></span>Transition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Transition::Transition </td>
          <td>(</td>
          <td class="paramtype">state_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classWeight.html">Weight</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classTransition.html" title="a Transition is defined by a sequence of antecedent states (body) the weight must be not null (null w...">Transition(s, w)</a> creates a transition with weight a copy of w and body (of size 1) the singleton (s) (terminal symbol). </p>
<dl class="section warning"><dt>Warning</dt><dd>the letter weight in the envelop w is cloned. </dd></dl>

</div>
</div>
<a id="ga97dce48d13fac75a4a444a68aae07608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97dce48d13fac75a4a444a68aae07608">&#9670;&nbsp;</a></span>label()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__output.html#ga22fde970e635fcf63962743b2d5c441d">label_t</a> Transition::label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>this transition must be terminal </dd></dl>

</div>
</div>
<a id="ga9e2e243bfa147bafd947f2cffd1da3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e2e243bfa147bafd947f2cffd1da3ec">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">state_t Transition::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>at(i) returns the ith state in the body. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>must be an index of the body. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba83dbc74a223a80ad7f8776847bd6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba83dbc74a223a80ad7f8776847bd6c2">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TransitionList::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>zero transition </p>
<dl class="section return"><dt>Returns</dt><dd>an empty transition </dd></dl>

</div>
</div>
<a id="gaa719dbdab17047360e889910795a07f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa719dbdab17047360e889910795a07f2">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t TransitionList::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of transitions. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of transitions in this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> </dd></dl>

</div>
</div>
<a id="ga88d07a1e47cc3ee537234861b7336dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88d07a1e47cc3ee537234861b7336dd6">&#9670;&nbsp;</a></span>isInitial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool WTA::isInitial </td>
          <td>(</td>
          <td class="paramtype">state_t&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the state is an initial state </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>TBR </dd></dl>

</div>
</div>
<a id="ga924a1c533383a7185b9d466b59c5a495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga924a1c533383a7185b9d466b59c5a495">&#9670;&nbsp;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransitionList.html">TransitionList</a> &amp; WTA::add </td>
          <td>(</td>
          <td class="paramtype">state_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add(s, i) register state s if s was already registered, return a reference to its transition list. otherwise, create state s with an empty transition list and returns a reference to it. moreover s is set as initial if i = true. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>suppr. flag initial </dd></dl>

</div>
</div>
<a id="ga01de1e03d09518b38ab69a2075276ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01de1e03d09518b38ab69a2075276ae2">&#9670;&nbsp;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTransitionList.html">TransitionList</a> &amp; WTA::add </td>
          <td>(</td>
          <td class="paramtype">state_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTransition.html">Transition</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add(s, t) add a transition with head s and with body/weight described in t if s was not registered, it is registered the transition t is added to the transition list of s and a reference to this transition list is returned moreover s is set as initial if i = true. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>suppr. flag initial </dd></dl>

</div>
</div>
<a id="ga91e272f4f9463149cd296f48e65a4185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91e272f4f9463149cd296f48e65a4185">&#9670;&nbsp;</a></span>abstract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WTA::abstract </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>abstract the leaf label values in domain [0..MAX_GRACE] every value &gt; MAX_GRACE is casted to MAX_GRACE the weights are summed accordingly </p>
<p>leaf labels in domain of <a class="el" href="classLabel.html" title="labels for nodes of output Rhythm Trees.">Label</a> (not <a class="el" href="classSerialLabel.html" title="static functions for serializable int encoding of input and output leaf symbols containing the follow...">SerialLabel</a>). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>TBR unused </dd></dl>

</div>
</div>
<a id="ga8dfef6b591f952f0fea9dae1f5e475c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dfef6b591f952f0fea9dae1f5e475c7">&#9670;&nbsp;</a></span>CountingtoStochastic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WTA::CountingtoStochastic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cast weights in all transitions. </p>
<dl class="section warning"><dt>Warning</dt><dd>this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> must have <a class="el" href="classWeight.html" title="A class of polymorphic weight domains for tree series.">Weight</a> Type "FloatWeight". this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> is casted into <a class="el" href="classWeight.html" title="A class of polymorphic weight domains for tree series.">Weight</a> Type "ViterbiWeight" divide by sum for target state </dd></dl>

</div>
</div>
<a id="ga5f3a0d868bf26b504cccc53b4d55e09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f3a0d868bf26b504cccc53b4d55e09a">&#9670;&nbsp;</a></span>CountingtoPenalty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WTA::CountingtoPenalty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cast weights in all transitions. </p>
<dl class="section warning"><dt>Warning</dt><dd>this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> must have <a class="el" href="classWeight.html" title="A class of polymorphic weight domains for tree series.">Weight</a> Type "FloatWeight". this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> is casted into <a class="el" href="classWeight.html" title="A class of polymorphic weight domains for tree series.">Weight</a> Type "TropicalWeight" composition of CountingtoStochastic and StochastictoPenalty </dd></dl>

</div>
</div>
<a id="gaff1196a45ffd1400bc4004e27b167218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff1196a45ffd1400bc4004e27b167218">&#9670;&nbsp;</a></span>PenaltytoCounting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WTA::PenaltytoCounting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cast weights in all transitions. </p>
<dl class="section warning"><dt>Warning</dt><dd>this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> must have <a class="el" href="classWeight.html" title="A class of polymorphic weight domains for tree series.">Weight</a> Type "TropicalWeight". this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> is casted into <a class="el" href="classWeight.html" title="A class of polymorphic weight domains for tree series.">Weight</a> Type "FloatWeight" inverse </dd></dl>

</div>
</div>
<a id="ga0bddc6750b18023be6976bd5cd46a2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bddc6750b18023be6976bd5cd46a2f5">&#9670;&nbsp;</a></span>StochastictoPenalty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void WTA::StochastictoPenalty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cast weights in all transitions. </p>
<dl class="section warning"><dt>Warning</dt><dd>this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> must have <a class="el" href="classWeight.html" title="A class of polymorphic weight domains for tree series.">Weight</a> Type "ViterbiWeight". this <a class="el" href="classWTA.html" title="class of schemas = weighted tree automata = weighted CFG.">WTA</a> is casted into <a class="el" href="classWeight.html" title="A class of polymorphic weight domains for tree series.">Weight</a> Type "TropicalWeight" -ln </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
